\newif\iftth
\def\Srel{\mathrel{S}}
\let\non\neg
\let\pr\preceq
\let\bs\backslash
\let\qs=\forall 
\let \ex=\exists
\let\vid=\emptyset
\let \inc=\subset
\iftth %makes error on \proclaim then the solution is to copy-paste the whole content of the file to a new file.
\def\sinc{\special{html:&#x228A;}}\def\vdash{\special{html:&#x22A2; }}
\def\P{\special{html: &#x2118;}} % voir liste http://www.alanwood.net/unicode/letterlike_symbols.html
\def\notinc{\special{html:&nsub;}}
\def\link#1#2{\special{html:<a href="http://}#1\special{html:">}#2\special{html:</a>}}
\def\bicup{\special{html: <font size=+2>&#X22C3;</font> }}
\def\eq{\ \Leftrightarrow\ }\def\imp{\ \Rightarrow\ }
\def\N{\special{html: &#x2115;}}
\def\A{{\special{html:&\#120016;}}} 
\def\vid{{\special{html:&\#216;}}}%{{\cal A}}%{{\special{html:<b>A</b>}}}%&#x1D4D0;<font face="Script">A</font>\special{html: &#1D49C;}}}
\def\cac{\special{html:&\#120018;}}\def\C{{\special{html:&\#120018;} }}%&#x1D49E;<b>C</b>
\def\B{{\special{html:&\#120017;}}}%{{\special{html:&#x212C;}}}%html: &#x212C;  <b>B</b>
\def\map{\special{html: &#x21A6; % &#x0918; &#x27FC;%&#x0918; ?&#x22A6;&#x2192; &#x22A6;&#x21FE; 
}}
\def\rc{{\special{html:&\#120033;}}}%{\special{html:&#x211B;}}
\def\nequ{\special{html: &#x21CE; }}\def\nimp{\special{html: &#x21CF; }}
\def\square{\special{html: &#x220E%25FB
;}}
\def\mathrel#1{\ #1\ }%
\def\bq{Q*}
\def\U{\special{html:&#x1D4E4;}}
\def\Up{\special{html:&#x1D4E4;<font size=-2> </font>}'}
\def\q#1{\special{html:&laquo;}#1\special{html:&raquo;}}
\def\qi#1{\special{html:&laquo;}{\it #1}\special{html:&raquo;}}
\def\f#1{\special{html:</i>}$#1$\special{html:<i>}}
\def\tp{T\special{html:<font size=-2> </font>}'}
\def\cqfd{\ifmmode \square\else\hfill $\square$\fi}
\def\st#1{\special{html:<h3>}#1\special{html:</h3>}}\let\stm=\st
\def\sur{\special{html: &#x21A0; }}
\def\et{\ \wedge\ }\def\ou{\ \vee\ }
\else
\let\et\wedge \let\ou\vee
\def\sur{\to\mkern-15mu\to}
\def\tp{T'}
\def\st#1{\medbreak\noindent{\bf #1}\sk}\def\stm#1{\medbreak\noindent{\bf #1}}
\def\link#1#2{#2\footnote{(*)}{http://#1}}
\let \imp=\Rightarrow \def\nimp{\not\imp}
\def\bq{\overline Q}
\input amssym
\def\f#1{$#1$}
\def\q#1{``#1"}\def\qi#1{``{\it#1}"} 
\catcode`\@=11
\def\ldisplaylinesno#1{\displ@y\halign{
  \hbox to\displaywidth{$\@lign\hfil\displaystyle##\hfil$}&
    \kern-\displaywidth\rlap{$##$}\kern\displaywidth\crcr
  #1\crcr}}\catcode`\@=12
\vsize=732truept%703truept%765truept% 776 760 681truept
\voffset=-4truemm
\hoffset=0truemm\hsize=442truept
\parindent=6.5mm
\mathchardef\sinc ="3820
\def\P{{\cal P}}
\let\bicup=\bigcup
\def\notinc{\not\inc}
\let\map=\mapsto
\let\eq\Leftrightarrow 
\def\nequ{\not\eq}
\font\tensym=msbm10    
\font\sevensym=msbm7
\font\fivesym=msbm5
\newfam\symfam
\textfont\symfam=\tensym
\scriptfont\symfam=\sevensym
\scriptscriptfont\symfam=\fivesym
\def\sym{\fam\symfam\tensym}
\def\R{{\sym R}}
\def\Q{{\sym Q}}
\def\N{{\sym N}}
\def\Z{{\sym Z}}
\def\A{{\cal A}}
\def\U{{\cal U}}\def\Up{\U'}
\def\B{{\cal B}}
\def\C{{\cal C}}\let\cac\C
\def\rc{{\cal R}}
\def\cqfd{\ifmmode \eqno\square\else\hfill $\square$\fi}
\catcode246=13  \def^^f6{\"o}
\fi
\let\sk=\medskip
\def\pp{\mathop{\hat{\prod}}}
\let\dl\displaylines
\let\x=\chi
\def\ii{\!\in\!}
\def\e{{\bf E}}
\def\nl{\hfill\break}
\def\m{{\rm m}}
\def\s{{\rm s}}
\def\cc{|_c}
\def\ce{{\cal E}}
\def\F{{\cal F}}
\def\t{{}^t\!}
\def\sst{\medbreak\noindent\it }
\font\gbf=cmbx10 at 12pt
\font\Gbf=cmbx10 at 14.4pt 
\def\vrai{1}\def\faux{0}%\iftth \def\vrai{{\rm true}}\def\faux{{\rm false}}\else \def\vrai{\hbox{true}}\def\faux{\hbox{false}}\fi
\def\mi{^{-1}}
\let\al\alpha
\def\V{{\cal V}}
\def\T{{\cal T}}
\let\ga\Gamma
\def\gr{\mathop{\rm Gr}}
\def\mor{\mathop{\rm Mor}}
\def\mo{$\tau$-fonction}
\def\tit#1{\centerline{\gbf #1}\smallskip
\iftth
\line{\hfill Sylvain Poirier}
\line{\hfill http://settheory.net/}
\else\line{\hfill\vbox{\hbox{Sylvain Poirier}
\rlap{\hbox{http://settheory.net/}}}}\fi}
%\def\tit#1{\bigskip\centerline{\gbf #1}\smallskip}
\def\im {\mathop{\rm Im}}
\def\In{\!\in\!}
\def\inv {\mathop{\rm Inv}}\def\de{\mathop{\rm Dom}\iftth\ \fi}
\def\mre#1{\mathrel{\rm #1}}
\def\si#1{\mathop{\sim}\limits_{#1}}
\def\Si#1{\mathrel{\si{#1}}}
\def\eg#1{\mathrel{\mathop{=}\limits_{#1}}}
\def\lra{\mathrel{\mathop{\leftrightarrow}}}%\limits_{#1}
\def\nni{\!\ni\!}
\let\ra\rightarrow
\let\bu=\bullet
\def\b{$\bullet$ }
\def\equ#1{\mathrel{\mathop{\Leftrightarrow}\limits_{#1}}}
\def\he{\hat =}
\def\Rel{\mathrel{R}}
\def\ul{\iftth\special{html:<ul><li>}\else\par \b \fi}
\def\li{\iftth\special{html:</li><li>}\else\par \b \fi}
\def\lu{\iftth\special{html:</li></ul>}\fi}
\tit{Основы математики}
\def\ens{\mathop{\rm Set}}\def\app{\mathop{\rm Fnc}}

\centerline{\gbf 1. First foundations of mathematics}
\st {1.1. Основы математики. Введвние.}

Математика –это наука, изучающая системы абстрактных элементарных объектов, воспринимаемых как существующие отдельно от нашего мира, единственная цель которых –быть точными, недвусмысленными (два объекта могут быть равными или разными, связанными друг с другом или нет; операция дает точный результат, и т.д.). Математика разделена на много областей: концепций или объектов изучения, которые можно формально определить как разнообразие (аксиоматичных) теорий. Каждая теория изучает какую-либо предположительно фиксированную систему (мир математических объектов), вид которой изначально определен (выбран из всех возможных математических систем) с помощью математического описания, которое называется {\it основой } этой теории.

Некоторые теории можно расположить в виде иерархий , где одни теории могут быть основой для других. Например, основы нескольких теорий могут иметь общую часть, которая представляет собой более простую теорию, модификации которой применимы к ним всем. 

Наука, изучающая основы математики как единого целого, была разработана как область математики под названием  {\it математическая логика},Она состоит (как и любая другая область) из определений и теорем, описывающих системы объектов (общая форма объектов, теории и их соответствующие, возможно, изученные системы), отвечая на многие философские вопросы и создавая общую структуру для всей математики. 

Во-первых и всегда, основы математики или теории –это то, что о них известно или выборочно принято. Затем изучение продвигается вперед путем выбора некоторых возможных следствий этой теории : новых понятий и информации вытекающих из предыдущей основы и присоединяющихся к ней, чтобы сформировать следующую основу. Другие варианты, не выбранные в данный момент, могут быть выбраны позднее, так как основа, на которой они могут возникнуть, продолжает существовать.  Таким образом, совокупность возможных следствий уже образует некую минимальную \q{реальность}  и можно сказать, что они ее исследуют, пока не возникнет возможность продемонстрировать нечто лучшее (см. Теорему полноты, представленную в Части 3). 
Фундаментальная работа состоит в том, чтобы, исходя из простой первоначальной основы, разработать более полную основу, которая наилучшим образом облегчает создание дальнейших интересных следствий данной теории. 

Несмотря на элементарность математических объектов, основы математики  (где основа каждой основы, в отличие от обычных математических работ, продвигается вперед от предполагаемой основы),оказываются достаточно сложными (хотя и не настолько, как физическая «теория всего»):будучи сами по себе одной из ветвей математики, укорененной на них, основы математики образуют не стартовую точку, а широкую движущую силу, петлей приблизительно соединяющуюся с самой собой, образованную из более или менее сложных этапов.  
 
(Это напоминает то, как в словарях дается определение каждого слова с помощью других слов, или это напоминает другую науку конечных систем: компьютерное программирование. Действительно, компьютерами можно просто пользоваться, зная, чтó ты делаешь, но не зная, почему это работает.  Их работа основана на программном обеспечении, которое было написано на некоем языке, потом скомпилировано другим программным обеспечением, а также на аппаратном обеспечении («железе») и процессоре, которые были сконструированы и изготовлены при помощи компьютеров. И это гораздо лучше, чем обстояло дело при зарождении этой области науки.)
 
И все же эта петля является истинной основой математики, поскольку ее части богаты полезными понятиями для разнообразных областей математики. 
В ней доминируют две теории: 
 
{\bf Теория множеств} изучает вселенную \q{всех математических объектов},от простейших до самых сложных, таких как бесконечные системы.Но в деталях она имеет неограниченное разнообразие возможных вариантов (не всегда одинаковых).

 
{\bf Теория моделей} это общая теория теорий (описывающая их формализм как систему символов) (миров) объектов, которые они могут описывать, называемые их {\it моделями} (их возможными интерпретациями). Ее дополняет теория доказательств (описывающая правила доказательств). Она по существу уникальна, она придает ясное и окончательное значение понятиям теории и теоремы в каждой теории.  
 
Каждая из них –это естественная структура, позволяющая дать формальное представление другой: теория моделей описывает каждую теорию множеств как аксиоматическую теорию, а также и ее саму лучше представить как следствие теории множеств (построение теорий и моделей как сложных объектов в теории множеств)чем как отдельную теорию. Таким образом, теория множеств –это одновременно и базовая структура для теории моделей, и ее объект изучения (но эти две копии теории множеств нельзя путать, даже если они построены по одним и тем же правилам). Но завершение этих формальных представлений потребует много времени. 

 
Специалисты по основам математики выбрали аксиоматическую теорию множеств Цермело-Френкеля (сокращенно ЦФ; или ЦФВ - Система Цермело-Френкеля с аксиомой выбора) как мощную теорию в ENLARGED FOUNDING CYCLE, которая может доказать многие сложные пропозиции или их недоказуемость. 
 
Математика начинается с введения некоторых простых понятий (IN THE FOUNDING CYCLE), которые, на первый взгляд, не основаны на других. Естественно начать с теории множеств, которая не полностью формализована как аксиоматическая теория. 
Ее обычно представляют как популяризированную или НЕЯВНУЮ версию ЦФВ, признавая ее аксиомы как необходимые или очевидные.

Но ЦФВ не является идеальным стартовым ориентиром для начал математики. Ее аксиомы менее НАТУРАЛЬНЫ, чем кажутся; полное обоснование их существования тоньше, чем то, что они просто результаты интуиции, исторически выбранные для связности и удобства результирующей системы. Но аксиомы только приносят свои требования в рассматриваемый мир внутри необходимой существующей коллекции теорий моделей, которая придает смысл этим аксиомам. Также, ЦФВ assumes  рассматривает всё как множества, множества множеств и т.д., построенные над пустым множеством. Но обычная математика при разработке на этой основе несколько громоздка и использует много объектов, не рассматриваемых как множества. Поскольку множества могут играть все эти роли, это не обязательно было формализовывать, но это по-прежнему представляет собой расхождение между  \q{теорией} и практикой математики. 



\st {1.2. Переменные, множества, функции и операции }
Давайте начнем рассмотрение математики с теории множеств, более непосредственно подходящей для математической практики, имеющей больше понятий и объяснений о контексте основ (теория моделей) и ее основных тонкостей (парадоксов). Начнем с трех понятий (видов объектов): элементов, множеств и функций; и по мере необходимости будем развивать ФОРМАЛЬНОЕ ПРЕДСТАВЛЕНИЕ, вместе с другими понятиями, символами и аксиомами, которые можно рассматривать как примитивные или нет, и которые могут быть необязательными. 


{\sst Константы}

{\it Символ константы }\/ –это символ, обозначающий уникальный объект, который называют ее {\it значением}. Примеры: 3, $\vid$, $\N$. В английском языке это имена собственные и названия, начинающиеся с определенного артикля (в единственном числе без дополнения). 


{\sst Свободные и связанные переменные}

{\it Символ переменной} (или просто {\it переменная})–это символ без закрепленной интерпретации. Каждая возможная интерпретация придает ему определенное значение и таким образом рассматривает его как константу.

Можно представить себе это как нечто, находящееся в пределах коробки. Если смотреть изнутри коробки, это можно использовать как константу : ее называют {\it свободной } или {\it фиксированной}.  Если смотреть снаружи, ее возможные значения рассматриваются во всем своем разнообразии: такую переменную называют {\it связанной}. 

{\sstДиапазоны и множества}

{\itДиапазон} переменной–это ее значение, когда она рассматривается как связанная: это знание (определение) всех ее возможных или допустимых значений, которые называются {\it элементами \/} этого диапазона. Любой диапазон переменной называется {\it множеством}. (Это \q{знание} в отличие от человеческой мысли, - абстрактное целое, которое может включать бесконечные количества объектов; элементы рассматриваются в массе: неупорядоченными, без учета контекста).
Переменная имеет диапазон, если его можно связать, т.е. когда возможен обзор, охватывающий все ее возможные значения. 

Говорят, что переменная {\itИЗМЕНЯЕТСЯ В ПРЕДЕЛАХ/ЗАКЛЮЧАЕТСЯ В ПРЕДЕЛАХ/ОХВАТЫВАЕТ} множества, если она связана с этим множеством как с диапазоном.
В данном диапазоне может быть представлено любое количество переменных, независимо друг от друга и от других переменных. 

Кантор определял множество как \qi{соединение в единое целое хорошо различимых предметов нашего созерцания или нашего мышления}. Он объяснял Дедекинду : \qi{Если совокупность элементов множественности можно представить как \q{существующие одновременно}, так, чтобы их можно было воспринимать как \q{единый объект} (или \q{завершенный объект}),  я называю это непротиворечивой множественностью или \q{множеством}.} (Мы выразили эту \q{множественность} как множественность значений переменной).


Он описал противоположный случай как \qi{противоречивую множественность} где \qi{признание совместного существования всех ее элементов ведет к противоречию}. Но непротиворечивости не достаточно для того, чтобы дать общее определение множеств: непротиворечивость не означает истинности (противоположное этому заявление может быть истинно, но недоказуемо); факты непротиворечивости сами представляют собой распространенный случай недоказуемых истин; и две множественности, которые отдельно друг от друга непротиворечивы, могут противоречить друг другу (\link{rationalwiki.org/wiki/Omnipotence\_paradox}{Парадокс всемогущества}). 

Систематическое переименование связанной переменной во всем объеме «коробки» в другой символ, не используемый в том же контексте  (той же коробке), с тем же диапазоном, не меняет значения целого. На практике, одна и та же буква может обозначать несколько отдельных связанных переменных (у которых отдельные коробки), которые могут принимать различные значения, так как их никогда не интерпретируют (свободно) вместе, и поэтому они не сравнимы. Обычный язык постоянно это делает, используя небольшое количество переменных символов (\q{он}, \q{она}, \q{оно}\dots)
\goodbreak
{\sst Функции}

{\it Функция}–это любой объект $f$ ведущий себя как переменная зависящая от другой переменной с диапазоном, обозначенным Dom f, называемого ее {\it аргументом},  диапазон которого обозначается символом $\de f $ : когда этот аргумент фиксированный (обозначенный как символ  $x$), $f$ превращается в константу (обозначена как $f(x)$). Другими словами, $f$ содержит следующие данные:
\ul Множество, называемое {\it область определения} $f$, обозначено как $\de f$
\li Для каждого элемента $x$ из области определения $\de f$, объект $f(x)$ называют {\it ИЗОБРАЖЕНИЕМ/ПРЕДСТАВЛЕНИЕМ $x$ от $f$} или {\it значением  $f$ при $x$}. %on, in ?
\lu

{\sst Операции}

{\it Операция }–это обобщенная функция к случаю конечного списка аргументов (переменных с данными относительными диапазонами), дающая результат (значение), когда все аргументы фиксированные.  Число $n$ аргументов называют его {\it арностью\/}; операция называется  {\it $n$-арной}. Ее называют  {\it унарной,} если $n=1$ (это функция), {\it бинарной} если $n=2$, {\it тернарной} если $n=3$\dots Нульарные операции бесполезны, поскольку их можно заменить их значением; мы увидим, как создавать операции с арностью $> 1$ посредством функций. 

Значение бинарной операции $f$ над ее фиксированными аргументами называется (со значениями, придаваемыми)) $x$ и $y$, обозначается $f(x,y)$. 
Так что, вместо символов, аргументы представлены левым и правым положением в скобках, которые заполняются любым выражением, которое придает им желаемое значение. 


\st {1.3. Структура теорий: объекты, метаобъекты, типы и структуры}

Основание теории имеет два уровня. Во-первых, мы должны установить {\it формальное представление} которое будет содержать теорию: логическую структуру, или грамматику. Это определяет, каким образом можно выразить содержание теории и вывести ее следствия. Вначале, мы введем только 2 из этих потенциально полезных видов формального представления. Теории в формальном представлении {\it логики первого порядка} будут называться здесь {\it генерическими теориями} ; особое формальное представление будет введено для теории множеств. В третьей части будут представлены другие виды формального представления. 

Каждая теория имеет свои собственные {\it понятия}, обычно обозначаемые общими названиями. Понятие –это вид переменных, допускаемых в языке теории, которые в каждой модели (интерпретации теории) относятся к диапазону возможных значений этого вида переменной. 
{\it Объект} теории в модели –это любой допускаемый элемент любого понятия (возможное значение любой переменной) теории в этой модели. 
разные возможные формальные представления, кроме представления в нашей теории множеств, будут управлять переменными следующим образом: их единственными принятыми понятиями будут {\it типы} их количество обычно является конечным), классифицирующие и переменные, и объекты. Каждый объект будет принадлежать только к одному типу - типу переменных, которые могут давать ему название. 

 В имплицитной структуре теории моделей мы обсудим несколько теорий $T$ и их возможные модели $M$ (системы, описываемые $T$). Итак, переменные $T$ и  $M$ –это переменные теории моделей, соответственно принадлежащие ее понятиям \q{теория} и \q{модель}. Но когда мы будем концентрироваться на одной теории (множеств) с предположительно фиксированной моделью, эти переменные будут фиксированными и, таким образом, исчезнут вместе с понятиями, к которым они относятся, так как станут имплицитными. Из теории моделей, структура будут сведена к {\it теории одной модели}. 
 Различные версии теории (одной) модели соответствуют различным формальным представлениям для теорий, но по-прежнему имеют много сходств (общих понятий). (Мы не будем здесь указывать формальные представления, которыми выражены сами теория моделей и теория одной модели.)


Examples of notions from various theories:
\sk
\halign{\hfil#\hfil\quad&\hbox{#}\cr
{\bf Theory}&{\bf Kinds of objects (notions)}\cr
Generic theory &Pure elements classified by types\cr
Set theory &Elements, sets, functions, operations, relations, tuples \dots\cr
Model theory &Theories, systems and their components (listed below)\cr
One-Model theory &Objects, symbols, types, structures (operators, predicates), formulas\dots\cr
Arithmetic &Natural numbers\cr
Linear Algebra &Vectors, scalars\dots\cr
Geometry &Points, lines, circles\dots\cr}\sk


The whole system made of the data of a theory $T$ and a system $M$ that is a model of $T$, constitutes a model $[T,M]$ of a one-model theory $T_1$. The notions of one-model theory, normally interpreted in $[T,M]$, classify the components of $T$ (\q{type}, \q{symbol}, \q{formula}\dots), and those of $M$ (\q{object}, and tools to interpret $T$ there). But the same notions of one-model theory can be interpreted in its other model $[T_1,[T,M]]$, which will be expressed by putting the prefix meta- on them. 

By its notion of \q{object}, one-model theory distinguishes the objects of $T$ in $M$ among its own objects in $[T,M]$, that are the meta-objects. Таким образом, каждый объект будет мета-объектом. Однако на практике мы будем делать исключение и называть {\it мета-объектами} только то, что не является объектами. . 

В отличие от теории множеств, теория одной модели дает диапазон каждой переменной своей изученной теории. Однако каждый диапазон, то есть понятие, является только мета-объектом.

Как только зафиксировано формальное представление, приходит очередь содержания основ теории, которое является отличительной чертой теории и пытается определить предполагаемый вид ее моделей и их различные концепции (вокабуляр). Эта основа теории состоит из (математически условного, но интуитивно сконструированного) тройного списка данных, структурированных в виде 3 слоев:
\nl
1) Список {\it абстрактных типов} цель которых – установить типы объектов;
\nl
2){\it Язык } : список {\it символов структуры}, цель которых –установить отношения объектов к конкретным типам;
\nl
3)Список формул, называемых  {\it  аксиомами}  выбранных из множества всех возможных закрытых формул, т.е 1.4.).


Instead of being described by one-model theory, the same system $[T,M]$ can be understood as translated into set theory, representing components of $T$ by components of set theory while only those of $M$ become objects, as follows.
Variables of $T$ are just kept as variables of set theory. Each abstract type becomes a free variable, whose value is a set called an {\it interpreted type}. 
Точнее, используя стандартную форму перевода, которая подходит для любой генерической теории: все объекты будут переведены в чистые элементы (в отличие от обычной точки зрения, что геометрия определяет линии как множества точек). 

Абстрактные типы и структурные символы все переводятся как свободные переменные, которые остаются свободными, пока модель остается фиксированной. Их значения являются основными компонентами модели, компонентами, которые определяют ее. 
This integrates all theories (arithmetic, geometry\dots) and their diversity of possible models, in the same set theory with a fixed model (also called {\it universe}). 


\st{1.4. Structures and expressions}
{\sst Structures}


Структуры (and thus structure symbols) могут быть 2 видов: операторы и предикаты. Как переменная теории множеств, значение каждого символа оператора является оператором {\it оператор}, т.е. операция, где диапазон каждого аргумента представляет собой тип, и значения относятся к одному типу; арность (или список аргументов предоставленных как зона вокруг символа), абстрактный тип каждого аргумента и тип значений даны с каждым символом. Нульарный оператор –это постоянный символ, напрямую называющий фиксированный объект. Но тем не менее это свободная переменная теории множеств. Унарный оператор, т.е. функция, будет называться {\it функтор}.

Модель завершается стандартным специальным типом: типом {\it булевых} выражений, состоящих из обоих элементов \q{истинно} ($\vrai$) and \q{ложно} ($\faux$). Переменная этого типа (за пределами теории) называется {\it Булева переменная}. Ее добавление к списку типов обобщает операторы до пара-операторов{\it пара-операторов}. A {\it Связка}– это пара-оператор с только булевыми аргументами и значениями. {\it Предикат} –это пара-оператор с одним или более аргументами, среди которых нет булевых, и с булевыми значениями. {\it Структура}–это оператор или предикат. 

Structures (interpretation of symbols from the language of a theory in a model) give to the elements of each type their roles of possibly complex objects. In set theory, the role of sets is given by the binary predicate $\in$ : for any element 
$x$ and any set $E$, the claim that (the value of) $x$ is a possible value of a variable with range $E$, is written $x\in E$ (that reads : $x$ is in $E$, or an element of $E$).
ZFC set theory is defined as a generic theory with one type \q{set}, only one structure symbol $\in$, and axioms. But our set theory will not be generic, and will include other symbols contributing to give their roles to sets, functions and other types of objects.

функции играют свою роль с помощью функтора $\de$ (задавая их области) and the {\it function evaluator}, binary operator giving the value $f(x)$ of any function $f$ at any element $x$ of $\de f$.

Теория одной модели, формализованная как генерическая теория, будет придавать \q{типам}  двойную роль абстрактных и интерпретированных типов.  Также, те же мета-объекты могли бы играть роли структурных символов и структур, за исключением того, что понятие \q{структуры} будет включать другие операции между типами, помимо операций, обозначенных символами (мы не можем допустить их \q{все} независимо от внешней вселенной, из которой они взяты, которая не релевантна здесь).

{\sst Terms and formulas}


Для любого данного списка абстрактных типов и символов структуры теории, a {\it term} is a finite system of occurrences of symbols, aiming to designate an object (его значение) как только модель и значения свободных переменных зафиксированы. (Вхождение символа –это его появление где-то, например, «x+x» имеет два вхождения х и одно вхождение +.). Мы называем {\it формулой} систему, сходную с термом, но без булевых значений. {\it Выражение} может быть термом или формулой. 


Expressions can use the following kinds of symbols :
\ul Variables
\li Structure symbols (operators and predicates) from the language
\li One equality symbol per type (predicate with 2 arguments of this type) abusively all denoted =, interpreted in the standard way.
\li Connectives
\li Binders: generic theories only use both quantifiers ($\qs$ and $\ex$, see 1.8.), but our set theory will have more (see 1.7.).
\lu

Выражения строятся последовательно, каждое как данные (вхождение) символа, называемого его корнем, и список ранее построенных выражений (и, возможно, переменных символов). Этот корень определяет тип значений (и таким образом проводит различие между термами и формулами) и формат этого списка (количество пунктов и тип каждого из них). Для символа пара-оператора, этот формат задается списком его аргументов. 

Первые термы –это термы, сведенные к вхождению символа константы или переменной, они называются {\it атомные термы}. Булевы константы $\vrai$ и $\faux$ (нульарные связки) – это первые формулы.

Для других символов требуется непустой список, таким образом, им нужны условные знаки, чтобы его представить. Большая часть символов бинарных пара-операторов выглядят как условный знак между двумя аргументами (добавление обозначается x+y вместо первоначального формата операций  +(x,y)); другие (умножение, степень) обозначаются неявно, без использования условного обозначения. 
Другие символы выражаются несколькими условными знаками, устанавливающими границы пунктов списка. Скобки могут или компоновать буквенные изображения символов как интерпретатор функции, или использоваться для того, чтобы выделить под-выражения и их соответствующие корни, как в (x+y)n.

Выражение {\it закрыто}, если оно не имеет свободной переменной (все переменные связаны с связками см. 1,7), так что его значение зависит только от системы объектов (модели) интерпретирующей типы и символы теории. Список{\it аксиом},  выбранный из множества замкнутых формул, выражает необходимые свойства моделей, т.е. выбор систем, где все эти аксиомы истинны, чтобы они могли быть\q{возможными моделями}теории, исключив из названия \q{модели} любую систему, где аксиома не верна.

{\sst Структуры определённые выражениями; классы}

В теории одной модели {\it структура\/} (оператор или предикат) это любая операция между типами объектов (например, объекты, названные структурными символами), определяемая выражением (термином или формулой) и списком выбранных свободных переменных чтобы связать в роли аргументов. Эта структура зависит от других переменных оставшихся свободными, называемых ее {\it параметрами} (в то время как связанные переменные внутри выражения, невидимые снаружи, здесь не учитываются). {\it Класс\/} унарный предикат рассматриваемый как множество объектов, для которых он истинный.

 Давайте расширим язык теории, введя один (или более) структурный символ. Если  \q{константы}  (то есть, нульарные константы ) ведут себя, как свободные переменные, их роль могут выполнять обычные переменные теории. Это можно использовать, чтобы назвать структуру, определяемую выражением (или одним из конечного списка выражений), тем самым сокращая это выражение. В этом случае, такой символ может быть связан (совпасть по диапазону со структурами, которые являются его предполагаемыми значениями) путем связывания параметров этого выражения. Но в других случаях (символы с ненулевой арностью, могущие представлять любую структуру, даже структуру, не определяемую параметрами), эти символы, как правило, больше не могут быть связанными, поскольку никакая аксиома не может формально заявить, что они совпадают по диапазону со всеми операциями данной арности между данными типами объектов. 

Назовем {\it инвариантной структурой} любую структуру, определяемую без параметров. Каждый символ в языке теории представляет инвариантную структуру (которую он определяет без параметров). Наоборот, инвариантные структуры могут быть названы новыми символами, которые будут добавлены к языку теории, сохраняя ее глубокий смысл (доказуемость, структуры, инвариантные структуры\dots). Такие правила для разработки теории подробно изложены в п. 3.2.


\st{1.5. Связки}


 Вот наиболее полезные связки в порядке арности $n > 0$, по своим свойствам для всех значений логических переменных (заменяемых формулами) $A$, $B$, $C$.
\smallskip
\noindent $n=1$ : отрицание $\non$ обменивает булевы выражения ($\non A$ читается \q{не как $A$}): 
$\non\vrai\eq\faux, \non\faux\eq\vrai, \non(\non A)\eq A$. обозначается также корнем из аргумента (формируя другой символ в том же формате)):   $(x\not=y)\eq\non(x=y)$ (\q{$x$ отличается от $y$}); $x\notin E\eq\non(x\in E)$ (\q{$x$ не принадлежит к $E$}). 



\smallbreak
\noindent $n=2$ :

$\et$ (и): верно только тогда, когда оба аргумента верны;

$\ou$ (или): верно, за исключением случаев, когда оба аргумента ложны;

$\imp$ : $A\imp B$ может быть прочитано как \q{A подразумевает B}, \q{$A$ -достаточное условие для $B$}, или \q{$B$ является необходимым условием $A$}, и означает $((\non A) \ou B)$. Когда это верно за исключением случаев, когда $A$ истинно, а $B$ is false, ложно, это означает, что если верно $A$, то $B$ также верно, но в противном случае оно не дает нам информации (будучи истинно).

Формула $(\non B\imp \non A)$ называется {\it контрапозитивной \ } из $(A\imp B)$, и эквивалентна ей.

$\eq$ (эквивалент), равенство логических значений: $(A\eq B)\eq((A\imp B)\et (B\imp A))$. Доказательство что $A\eq B$ может быть получено из импликации $(A\imp B)$, то другой $(B\imp A)$, называется его {\it обратное}.

Его отрицание $A\nequ B$ можно также прочитать как отрицание аргумента $(A\eq \non B)$, либо как \q{исключающее или} $((A\ou B)\et \non(A\et B))$.
Отрицания обменивают различные связки:
$$\eqalign{
(A\ou B)&\nequ (\non A \et \non B)\cr
(A\et B)&\nequ (\non A\ou \non B)\cr
(A\imp B)&\nequ(A\et\non B)\cr}$$
Это превращает свойства ассоциативности и дистрибутивности в различные формулы:
$$\eqalign{((A\et B)\et C)&\eq (A\et (B\et C))\cr
((A\ou B)\ou C)&\eq (A\ou (B\ou C))\cr
(A\imp(B\imp C))&\eq((A\et B)\imp C)\cr
(A\imp(B\ou C))&\eq((A\imp B)\ou C)\cr}$$
$$\eqalign{(A\et(B\ou C))&\eq((A\et B)\ou(A\et C))\cr
(A\ou(B\et C))&\eq((A\ou B)\et(A\ou C))\cr
(A\imp(B\et C))&\eq((A\imp B)\et(A\imp C))\cr
((A\ou B)\imp C)&\eq ((A\imp C)\et (B\imp C))\cr
((A\imp B)\imp C)&\eq ((A\ou C)\et (B\imp C))\cr
(A\et(B\imp C))&\eq ((A\imp B)\imp (A \et C))
}$$
$n\geq 3$ : последовательности $\et$ (конъюнкции) такие как $(A\et B\et C)$, а $\ou$ (дизъюнкции) такие как $(A\ou B\ou C)$ получают путем удаления скобок благодаря ассоциативности. Утверждение конъюнкции равнозначного утверждению всех его компонентов. Кроме того, любая последовательность формул связанных  $\eq$ и $\imp$ сокращает последовательность требований (связанных $\et$) каждого звена между соседними формулам:
$$\eqalign{
\faux&\imp A\imp A\imp \vrai\cr
(\non A)&\eq (A\imp \faux)\eq(A\eq \faux)\cr
(A\imp B\imp C)&\eq((A\imp B)\et(B\imp C))\imp (A\imp C)\cr
(A\eq B\eq C)&\eq ((A\eq B)\et(B\eq C))\imp (A\eq C)\cr
(A\et A)\eq (A\et\vrai)&\eq A\eq (A\ou A)\eq (A\ou \faux)\eq (\vrai\imp A)\eq (A\eq \vrai)\cr
(B\et A)\eq (A\et B)&\eq(A\et(A\imp B))\imp B\imp (A\ou B)\eq (B\ou A)}$$

{\noindent\it 
Аксиомы равенства}

для любого функтора $T$ и объектов $x, y$ (что может символизировать термы с параметрами), $$x=y\imp T(x)=T(y)$$
Аналогично для любого унарного предиката $A$ мы имеем $x=y\imp (A(x)\eq A(y))$. 

Таким образом, равенство между термами $x=y$ позволяет заменять любое вхождение (я) $x$ на $y$ в любом выражении без влияния на результат. Это относится, в частности, к случаям, когда символ определен термом: они равны, и взаимозаменяемы в любом выражении.
Также аксиомы и другие законы выражаются с использованием переменных символов заменяемых термами  в их использовании.

\st{1.6. Классы в теории множеств}

{\sst Теория множеств в создании цикла}

Теория одной модели не может быть полностью формализована в логике первого порядка (требуется аксиома второго порядка чтобы исключить бесконечно большие \q{выражения} и \q{доказательства }, см. часть 3), но только при переводе в теорию множеств. Как компоненты ее модели $[T, M]$ названы там свободными переменными, их изменчивость создает это множественно-теоретическое выражение теории моделей (общий обзор основ математики).

Теперь пусть $T_0$ будет множество теоретическим выражением внешней теории, что соответствует $T$ (определяется по тем же правилам): каждый компонент $T_0$ переводится в $T$ преобразованием его в замкнутый терм (по-прежнему теории множеств) определяя его образ в $T$. 
Таким образом, модель $M$ из $T$ косвенно является также моделью из $T_0$. 

Но мы выберем теории $T$ как формализацию теории множеств (переведенную как родовая теории методом объясненным в 1.8 и 1.9), интерпретируя его концепции в $M$. Таким образом наше выше установленное использование теоретической концепции множество во внешней вселенной необходимо будет отличить от него путем добавления префикса «мета-» .

теоретические концепции множеств могут быть хорошо отражены интерпретацией их мета-множеств, но их не следует путать. Вместо стандартного представления всех объектов в виде чистых мета-элементов, роль множеств  обычно будут играть мета- множества из тех же элементов (аналогично и для функций), позволяя любому множеству $E$ быть классом (определенным с $x\in E$  аргументом $x$ и параметром $E$), в то время как любой класс является мета-множеством объектов. Но некоторые мета-множества объектов, будучи неопределимыми, не являются классами; и некоторые классы, такие как вселенная (класс всех объектов, определяются путем 1), не являются множествами. 

{\sst Definiteness classes}

Классы являются очень общим видом понятий, которые заменят типы для выражения теории множеств. Действительно, все объекты должны быть включены в качестве \q{элементов} которые могут принадлежать множествам (чтобы избежать бесконечного деления на множества элементов, множества, функции, смешанные множества\dots). Таким образом, понятия множеств и функций будут представлять собой классами названные символы: множество = \q{представляет собой множество}, $\app =$ \q{функция}.

(Для этого мы могли бы сохранить 3 типа, где каждое множество будет включено дважды, как множество и элемент, определенные функтором из множеств к элементам. И то же самое для функций. но этой идеи все равно недостаточно для нашей теории множеств которой потребуется больше классов как понятий)

В общих теориях, синтаксическая коррекция выражения (что подразумевается в понятии \q{выражения}) гарантирует, что оно примет определенное значение, для всех данных в модели с фиксированной системой значений ее свободных переменных в этой модели. Но в теории множеств, это по-прежнему может зависеть от ее свободных переменных. Таким образом, структура или выражение $\A$ будет названо {\it определенной} когда он на самом деле принимает значение для данных значений своих аргументов в модели. Это определенное состояние $\A $ само по себе является определенным предикатом (выраженным формулой) $d\A$, с теми же свободными переменными. Выражения должны использоваться только, где они определены, что и будет сделано естественно. 

Классы определяются определенными одноместными предикатами. Мета-область любой унарной структуры $\A $, это класс определенный $d\A $, с теми же аргументами и параметрами, и называется его {\it классом определенности.}.

Определенное состояние $(x\in E)$ установлено $\ens(E))$. Состояние оценщика функции  $f(x)$ это $(\app (f)\et x\in \de f)$. 
Но определенность последней формулы должна быть объяснена следующим образом.


{\sst Extended definiteness}

теория с частично определенной структурой может быть формализована (переведена) как теория с одним типом и везде определенными структурами, сохраняя нетронутыми все выражения и их значения, где они определенные: модели переводятся в одном направлении, путем придания условных значений неопределенным структурам (например, постоянное значение), а в обратном направлении, путем игнорирования этих значений. Таким образом, выражение с неопределенным подвыражением могут быть признано определенным, если его значение не зависит от этих дополнительных значений.

Для всех предикатов $\A$ и $\B$, давайте придадим $\A\et \B $ и $\A\imp \B $ одно и то же условие определенности  $(d\A \et(\A\imp d\B ))$ (нарушая для  $\A\et \B$, симметрию между $\A$ и $\B$, которую не обязательно восстанавливать). Таким образом, они будут рассматриваться как определенные, если $\A $ ложно и $\B $ не является определенным, с соответствующими значениями $\faux $ и $\vrai $.

Это гарантирует определенность самих условий определенности, а также $d\A \et \A $ и $d\A \imp \A $ (соответственно расширеняя $\A $ на $\faux $ и $\vrai $ где это не было определенным). 
Формулы $\A \et(\B \et \cac )$ и $(\A \et \B )\et \C $ имеют одно и то же условие определенности $(d\A \et (\A \imp (d\B \et (\B \imp d\cac ))))$.

Для любого класса $\A$ и любого унарного предиката $\B $ определенного во всех $\A $, класс определенный (всюду определенным) предикатом $(\A \et \B )$, называется {\it подкласс \f{\A } определяемый на} $\B $.

\st{1.7. Связанные переменные в теории множеств}

последний вид символообразующих выражений -  это связки (связывающие символы), которые связывают одну (или более) переменные  (скажем, х) с выражением F, которое использует переменную х в дополнение к переменным символам , которые присутствуют (со значением) снаружи. Такой символ таким образом отделяет \q{внутреннее} подвыражение $F$ с помощью $x$ как свободное, с \q{наружи}
где $x$ связан. Выражение {\it закрыто } если все его переменные связаны (содержатся связками).

Таким образом, он принимает в качестве данных, символ  $x$  и выражение $F$,  и придает значение в зависимости от структуры, с аргументом $x$, определяемым  $F$. Это значение не может записывать всю структуру (которая не является объектом), но дает информацию от нее. 
Точный синтаксис отличается в теории множеств и в общей теории, которые управляют диапазонами по-разному.
В общих теориях, диапазоны - это типы, неявные данные связывающих символов. Но в теории множеств, диапазон связанной переменной представляет собой множество, объект, заданный в качестве аргумента связки (как значение терма, который не использует $x$), в дополнение к вышеуказанным данным. 

Давайте рассмотрим основные связки в теории множеств.

{\sst Определения функций термами}

{\it Определитель функции} $(\ \ni\ \map\ )$ связывает переменную $x$ с диапазоном $E$ на терме сокращенно обозначенным как $t(x)$ (с возможными неявными параметрами), соблюдая синтаксис $(E\nni x\map t(x))$, иногда сокращенно обозначается как $(x\map t(x))$  когда $E$ определяется контекстом. Определенный, если $t(x)$ является определенным для всех $x$ из $E$, он принимает функтор определяемый $t$ и ограничивает его класс определенности до $E$, чтобы дать его как функцию с областью $E$. Этот перевод с функтора на функции, приблизительно переворачивает перевод, сделанный другим определителем функции (от функций к их роли определителей функторов в множествах).

Другие понятия будут определены как классы объектов с помощью инструментов перевода объекта в его роль, и наоборот. Для любого вида мета-объектов, играющих роль объектов (которые можно опосредованно использовать в выражениях в качестве объектов: класс как множество\dots), теория множеств обогатится инструментами которые позволят прямо представить их как объекты. Существующие обьекты (множества или функции) могут играть новые роли, предлагая свои инструменты новым объектам. Таким образом, единственные необходимые переводы между объектами играющими одну и ту же роль, свяжут различные полезные представления нового объекта с помощью старых.

{\sst Формализация операций и каррирование}


$n$-арные операции выступающие в качестве $n$-арных операторов между $n$ множествами, оформляются:
\ul $n$ функторами области (имеющими мало практической пользы);
\li an $(n + 1)$-арной оценщиком, с аргументами операции $f$ и ее аргументами $x_1,\cdots,x_n$, написанными $f(x_1,\cdots,x_n)$; 
\li определителем операции, связующим $n$ переменные с их соответствующими диапазонами на терме. Единственное связывание $x$ к $E$ и $y$ к $F$ на $t$ пишется $(E\nni x, F\nni y\map t(x,y))$. Мы можем сократить $(E\nni x, E\nni y\map t(x,y))$ как $(E\ni x, y\map t(x,y))$. \lu

Понятие операции может быть представлено в виде класса функций, следующим образом называемых  {\it каррирование}. В качестве операции определителя (связывание $n$ переменных) возьмем последовательность $n$ средств определителя функции (по одному для каждой переменной, которые надо связать); а  подобно  оценщику, $n$ использование оценщика функции:
$$\eqalign{f=(E\nni x, F\nni y\map t (x,y))&\simeq(E\nni x\map (F\nni y\map t(x,y)))=g\cr
f(x,y)&=g(x)(y)=t(x,y)}$$
промежуточная функция $g(x)=(F\nni y\map t(x,y))$ с аргументом  $y$, рассматривает $x$ as свободный и $y$ связанный.
Но это нарушает симметрию между аргументами и теряет данные $F$ когда $E$
пусто. Формализация без этих недостатков будет возможна с помощью наборов(2.1.).


{\sst Отношения и множествообразующие символы}

{\it отношение} выглядит как операция, но с логическими значениями, действующими в качестве предиката, аргументы которого встречаются в диапазоне множеств. The $n$-арные отношения оцениваются с $(n+1)$-арным предикатом, и определяются связывающими  $n$ переменными по формуле. Они могут быть представлены операциями по переводу Логических представлений в объекты. Но есть и другой метод.

Для любого унарного предиката $\rc $ определенного в множестве $E$, подкласс $E$ определенный $\rc$ представляет собой множество (диапазон переменной $x$ введенной в диапазоне $E$, так что она может быть связанной, из чего мы выбираем случаи удовлетворяющие $\rc(x)$), таким образом, {\it подмножество} $E$, обозначаемое $\{x\in E|\rc(x)\}$ (множество $x$ в $E$ такое, что $\rc(x)$): для всех $y$,
$$y\in  \{x\in E|\rc(x)\}\eq (y\in E\et \rc(y))$$
{\it образователь множества} $\{\ \in\ |\ \}$, связывающий $x$ к $E$ на $\rc$, будет использован в качестве определяющего для унарных отношений в $E$, фигурирующих в качестве подмножества $F$ от
$E$, оцениваемые $\in$ как предикаты $(x\in F)$ с аргументом $x$. Но эти предикаты определены по всей вселенной, давая 0 вне $E$ чьи данные будут потеряны. Это отсутствие оператора $\de$ не имеет значения, так как области $E$ как правило, определяются контекстом.

Как определитель функции (соответственно множествообразующий символ) записывает всю  структуру определенную данным выражением на данном множестве, достаточно задать любой другой связующий символ на том же выражении с той же областью, словно из функтора или унарного предиката добавлен к результату что функция, соответственно множества); $n$-арные отношения могут быть определены в каррированной форме одним средством образователя множества и $n-1$ средств определителя функции.


\st{1.8. Кванторы}

{\it Квантор} является связующим символом для формулы, с логическими значениями.
Квантор $Q$ связывающий $x$ с диапазоном $E$ по формуле $\rc(x)$, полностью пишется $Q x\in E,\rc(x)$. Иногда, область (тип или класс) ставится в качестве индекса: $Q_Ex,\rc(x)$, или остается неявным (установленным контекстом): $Qx,\rc(x)$.
Два основных квантора (под которыми и другие будут определены позже) - это:
\nl
---  {\it Квантор существования} $\ex$, который гласит \q{There exists $x$ (in\dots) such that\dots}
\nl
---  {\it Квантор всеобщности} $\qs$, который гласит \q{Для всех (или: для любого) $x$ (в\dots),\dots}). 

Они могут быть мета-определяемыми с помощью мета-функции $(x\map \rc (x))$ с одной и той же областью в силу
$$(\qs x,\rc (x))\ \eq\ (x\map \rc (x))=(x\map \vrai)\ \nequ\   (\ex x, \non \rc (x))\eq\ (x\map \non\rc (x))\not=(x\map \faux)$$
В теории множеств, $(\qs x\in E,\rc (x))\eq \{x\in E|\rc (x)\}=E$. 
Формула $(\qs x,\vrai)$ всегда истинна.
С классами,
$$\eqalign{(\ex_{\C} x,\rc(x))&\eq (\ex x, \cac(x) \et \rc(x))\eq\ex_{\cac \wedge\rc} x,\vrai\cr 
(\qs_{\!\C} x,\rc(x))&\eq (\qs x, \cac(x) \imp \rc(x))\cr
\qs x,(\cac(x)&\eq (\ex_{\C} y, x=y))
}$$

{\sst Включение между классами}

Считается, что Класс $\A$ включен в класс $\B$ когда $\qs x, \A(x)\imp \B(x)$. Тогда $\A$ - это подкласс $\B$, как $\qs x,\A(x)\eq (\B(x)\et \A(x))$. И наоборот, любой подкласс $\A$  включен в подкласс $\B$ что подразумевает для любого предиката $\cac$ (в случаях определенности):
$$\eqalign{({\qs_\B} x, \cac(x))&\imp(\qs_{\A} x, \cac(x))\cr(\ex_{\A} x, \cac(x))&\imp(\ex_{\B} x, \cac(x))\cr
(\ex_\C x, \A(x))&\imp(\ex_\C x, \B(x))
\cr 
(\qs_\C x, \A(x))&\imp(\qs_\C x, \B(x))
}$$
\goodbreak

{\sst Правила доказательств для квантификаторов по унарному предикату} $\rc $


\proclaim Экзистенциальное введение. Если у нас есть %a term $t$ and a proof of \f{\rc (t)} (or 
условия \f{t, t', \cdots} и доказательство \f{\rc (t)\ou \rc (t')\ou \cdots}, тогда \f{\ex x,\rc (x)}.

\proclaim Экзистенциальное устранение. Если \f{\ex x,\rc (x)}, то мы можем ввести новую свободную переменную $z$ с гипотезой
\f{\rc (z) } (последствия будут истинными, без ограничения общности).

Эти правила выражают  смысл $\ex$ : переходя от $t, \cdots $ к $\ex$ затем из $\ex$ к $z$, это все равно что позволить $z$ представлять одну из $t, t', \cdots $ (не зная, какую именно). Они придают тот же смысл $\ex_\C$ относительно его 2 вышеприведенных эквивалентных формул, минуя расширенное правило определенности для $(\cac \et\rc)$ сосредоточив внимание на случае, когда $\cac(x)$ является истинным и, следовательно $\rc(x)$ является определенным.

В то время как $\ex$ появился как обозначение объекта, $\qs$ появляется в качестве правила вычета:

\proclaim Универсальное Введение. Если из всего лишь гипотезой \f{\cac(x) } на новой свободной переменной $x$ мы могли вывести \f{\rc (x)}, то \f{\qs_\C x, \rc (x)}.

\proclaim Универсальное Устранение. Если \f{\qs_\C x, \rc (x) } и $t$ является термом, выполняющим \f{\cac(t)}, то \f{\rc (t) }.

Представляя затем устранение $\qs $ как замену $x$ на $t$ в начальном доказательстве. 

Отчисления могут быть сделаны этими правилами, отражающие формулы
$$\eqalign{((\qs_\C x, \A(x))\et(\qs_\C x, \A(x)\imp \B(x))) &\imp (\qs_\C x, \B(x))\cr ((\ex_\C x, \A(x))\et(\qs_\C x, \A(x)\imp \B(x))) &\imp (\ex_\C x, \B(x))\cr (\qs_\C x, \A(x))\et(\ex_\C x, \B(x))) &\imp (\ex_\C x, \A(x)\et \B(x))}$$

{\sst статус открытых кванторов в теории множеств}

Теория множеств переводится в генерическую теорию путем преобразования в классах области кванторов:
$$\eqalign{(\ex x\in E, \rc(x))&\ra(\ex x, x\in E\et \rc(x))\cr
(\qs x\in E, \rc(x))&\ra(\qs x, x\in E\imp \rc(x))}$$
Теория множеств допускает только квантор над множествами, с названием
{\it ограниченный квантор}, в своих формулах, что для усиления будут называться {\it ограниченными формулами} (которые определяют предикат и могут быть использованы в выражении). Но его форма перевода как родовой теории позволяет существование кванторов  на любых классах (или вселенной), называемых  {\it открытыми кванторами}.Формулы с открытым кванторами в теории множеств будут называться {\it претензиями}. 
Их использование будет существенно ограничено декларацией истины замкнутых определенных претензий.
Они сначала будут аксиомами, потом теоремами (выведены из аксиом и с разными именами в зависимости от их важности: {\it теорема} является более важной, чем {\it предложение}, может быть выведена из {\it леммы}, и легко может привести к {\it следствию}. 

Открытые кванторы в претензии часто будут выражены как общие артикуляции языка  (неявно используя вышеуказанные правила доказательств) между их ограниченными подформулами (написанными символами теории множеств).

Образователь множества определяется претензиями. Он будет использован , чтобы показать, что класс всех множеств это не
множество, создавая все эти различия между классами и множествами, а также между открытыми и ограниченными кванторами:
\proclaim Теорема (парадокс Рассела). Для любого множества $E$ существует множество $F$ такое, что $F\notin E$. 

\noindent
Доказательство. $F=\{x\in E|\ens(x)\et x\notin x\}\imp (F\in F\eq (F\in E \et F\notin F))\eq(F\notin F\et F\notin E)$. \cqfd

\st{1.9. Первые аксиомы теории множеств}

Предикат включения $\inc$ между двумя множествами $E$ и $F$, определяется в 
$E\inc F\eq (\qs x\in E, x\in F)$. В нем говорится: $E$ входит в $F$, или $E$ является подмножеством $F$, или в $F$ входит $E$.

У нас всегда есть $E\inc E$. Последствия цепи также являются включениями цепей:
$$(E\inc F\inc G)\eq(E\inc F\et F\inc G)\imp E\inc G.$$
{\bf Первые аксиомы:}

{\iftth\else\parindent=2.8cm\fi $\qs x,\quad \non(\ens(x)\et \app(x))$

 $\qs_{\app} x,\quad\ens(\de x)$\nl
Для каждого терма $t$, $\qs E, \qs$(параметы), $\app(E\nni x\map t(x))$

$\qs_{\ens} E,F,\quad E\inc F\inc E\ \imp E=F$ (аксиома объемности).
 \smallskip}
\noindent Последний переопределяет равенство между множествами их равенством как классы (позволяя элементы в натуральном выражении): $E\inc F \inc E$ означает, что $E$ и $F$ имеют одинаковые элементы
 ($\qs x, x\in E\eq x\in F$) и подразумевает для любого предиката $\rc$ что $(\qs x\in F, \rc(x))\eq (\qs x\in E, \rc(x))$, а так же для $\ex$.

{\sst Переводя определитель}

При переводе теории множеств как родовой теории,  определитель функции  становится бесконечным символом операторов: для каждого терма $t$ с одним аргументом (и параметром), все  выражение $(E\ni x\map t(x))$  становится символом другого оператора, аргументы которых $E$ и параметры $t$. (Те, где каждое подвыражение внутри $t$ без вхождений  $x$ является единственным вхождением параметра, достаточно, чтобы определить другие).

Следующие аксиомы могут быть прочитаны как аксиомы общей теории, на что теория множеств переводится;
 а те, в зависимости от терм $t$ являются схемами аксиом (схема претензий = бесконечный список полученных претензий, заменяя дополнительный символ структуры любым возможным определяемым выражением):

\proclaim Аксиомы для функций. Для каждого терма $t$ с одним аргументом, любые значения его параметров, любого множества $E$
где $t$  является определенными, и любые функции $f$ и $g$, первая из этих аксиом обобщает следующие 3 из них:\def\disp#1{\iftth \matrix{#1}\else \displaylines {#1}\fi}
$$\disp{f=(E\nni x\map t(x))\eq (\de f=E\et (\qs x\in E, f(x)=t(x)))\cr\de (E\nni x\map t(x))=E\cr \qs x\in E, (E\nni y\map t(y))(x)=t(x)\cr(\de f=\de g\et \qs x\in \de f, f(x)=g(x))\imp f=g}$$

\st{1.10. Set generation principle}
Bounded quantifiers give sets their fundamental role as ranges of bound variables, unknown of
the predicate $\in$ which only sees them as classes. Technically, the bounded quantifier $(\ex \ \in \ , \ )$ can define the predicate $\in$ by $x\in E\eq (\ex y\in E, x=y)$
but cannot be defined from it in return without open quantifier. Philosophically, the
perception of a set as a class (classifying each object as belonging to it or not) does not
provide its full perception as a set (the perspective over all its elements as coexisting).

\proclaim Set generation principle. For any class \f{\C } defined by a bounded formula with parameters, if the expression \f{(\qs x,\cac(x)\imp \rc(x)) } of \f{\qs_{\C} } on an undefined (extra symbol of) unary predicate \f{{\rc} } is proven equivalent to a bounded formula (here abbreviated as \f{Qx,\rc(x)}), then \f{{\C} } is a set that can be named by a new operator symbol $K$ to be added to the language of set theory, with arguments 
the common parameters of \f{{\C} } and $Q$, and axioms : 

(For all accepted values of parameters), 
$\ens (K)\et (\qs x\in K, \cac(x))\et (Qx, x\in K)$.
\sk 

\noindent 
The equivalence of $Q$ and $\qs_\C$ is reducible to the
following system where $(\bq x, \rc(x))\nequ(Qx,\non \rc(x))$:\nl
(1) $\qs x, (\cac(x)\eq \bq y, x=y$) (in fact we just need $\qs x, \cac(x)\imp \bq y, x=y$)\nl
(2) $Qx, \cac(x)$\nl
(3) For all unary predicates $\A$ and $\B$ such that $\qs x, \A(x)\imp \B(x)$ we have $(Qx, \A(x))\imp(Qx, \B(x))$.
\smallskip

Indeed these 3 properties are already known consequences of \q{$Q=\qs_\C$}. Conversely,\nl
$((2) \et (3)) \imp ((\qs_\C x, \rc(x))\imp Qx,\rc(x))$\nl
$((1) \et \ex_\C  x, \rc(x))\imp \ex x, ((\bq y, x=y)\et (\qs y, x=y\imp \rc(y)))  \imp ((3)\imp \bq x,\rc(x))$.
\cqfd
\smallskip

(3) will often be immediate, by lack of any troubling occurrence of $\rc$ in $Q$ (negation, equivalence,
left of a $\imp$), leaving to verify (1) and (2). 
%Counter-example: $\bq= \C= \vrai$, $Q=\faux$ does not satisfy (2).

Here are examples of such operator symbols (denoting $D=\de f$):$$\matrix{
K&\{y\in E|\B(y)\}&\bigcup E&\im f&\vid&\{y\}&\{y,z\}\cr
dK&\qs x\in E, d\B(x)&\ens(E)\et\qs x\ii E,\ens(x)\kern -6mm&\app(f)\cr
\cac(x)&x\in E\et \B(x)&\ex y\in E,x\in y&\ex y\ii D,f(y)=x&\iftth\ \faux\ &\ x=y\ \else\faux&x=y\fi&x=y\ou x=z\cr
Q x,\rc(x)&\qs x\ii E,\B(x)\imp \rc(x)&\qs y\ii E,\qs x\ii y, \rc(x)&\qs x\ii D, \rc(f(x))&\vrai&\rc(y)&\rc(y)\et \rc(z)\cr
\bq x,\rc(x)&\ex x\ii E,\B(x)\et \rc(x)&\ex y\ii E,\ex x\ii y, \rc(x)&\ex x\ii D, \rc(f(x))&\faux&\rc(y)&\rc(y)\ou \rc(z)}$$

The definition of $K=\{x\in E|\B(x)\}$, that was only expressed as a class, can also be written as $((\qs x\in K,x\in E\et \B(x))\et (\qs x\in E,\B(x)\imp x\in K))$, or as $(K\inc E\et \qs x\in E, x\in K\eq \B(x))$.

The functor $\bigcup$ is the union symbol, and its axioms form the {\it axiom of union}.
\smallskip

The set $\im f$ of values of $f(x)$ when $x$ ranges over $\de f$, is called the {\it image} of
$f$. 

We define the predicate $(f:E\ra F)\eq (\app (f)\et\de f=E\et\ens(F)\et\im f\inc F)$, that reads \q{$f$ is a function from $E$ to $F$ }.
A set $F$ such that $\im f\inc F$ (i.e. $\qs x\in \de f, f(x)\in F$), is called a {\it range of $f$}. 
The more precise $(\app (f)\et\de f=E\et\im f= F)$ will be denoted $f:E\sur F$ ($f$ is a {\it surjection}, or {\it surjective function} from $E$ to $F$, or function from $E$ {\it onto} $F$).

\smallskip

The {\it empty set} $\vid$ is the only set without element, and is included in any set $E$ $(\vid\inc E)$.

Thus, $(E=\vid\eq E\inc \vid\eq \qs x\in E, \faux)$, and thus $(E\not=\vid\eq\ex x\in E,\vrai)$. 

This constant symbol $\vid$ ensures the existence of a set; for any set $E$ we also get $\vid=\{x\in E|\faux\}$.

We can reobtain $\ex$ by $(\ex x\in E, \rc(x))\eq \{x\in E|\rc(x)\}\not=\vid\eq (\vrai\in\im (E\ni x\map \rc(x)))$. 

As $(\de f=\vid\eq \im f=\vid)$, the only function with domain $\vid$ is called the {\it empty function}.

\smallskip
For all $x$, $\{x,x\}=\{x\}$. Such a set with only one element is called a {\it singleton}.

A set with 2 elements $x\not=y$, denoted $\{x, y\}=\{y, x\}$, is called a {\it pair}. 
\sk

Our set theory will later be completed with more symbols and axioms, either necessary (as here) or optional (opening a diversity of possible set theories).

\end

%Thus, proofs of $(\ex_\C x, \A(x))$ and $(\qs_\C x, \AC\A(x))$ would together give a contradiction.
