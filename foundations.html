<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 4.03">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 <style type="text/css"><!--
 .tiny {font-size:30%;}
 .scriptsize {font-size:xx-small;}
 .footnotesize {font-size:x-small;}
 .smaller {font-size:smaller;}
 .small {font-size:small;}
 .normalsize {font-size:medium;}
 .large {font-size:large;}
 .larger {font-size:x-large;}
 .largerstill {font-size:xx-large;}
 .huge {font-size:300%;}
 --></style>
    
<title> \gbf Основы математики</title>
 
<h1 align="center"><span class="roman"><b><span class="large">Основы математики</span></b></span> </h1>
<div class="p"><!----></div>

<table align ="left" border="0" width="100%"><tr><td align="right">
 Sylvain Poirier</td></tr></table><!--hbox-->
<br clear="all" />
<div class="p"><!----></div>
<table align ="left" border="0" width="100%"><tr><td align="right">
 http://settheory.net/</td></tr></table><!--hbox-->
<br clear="all" />


<div class="p"><!----></div>

<table align="center" border="0"><tr><td>
1.Первые основы математики</td></tr></table><!--hboxt-->
<h3>1.1. Основы математики. Введвние.</h3>

<div class="p"><!----></div>
Математика –это наука, изучающая системы абстрактных элементарных объектов, воспринимаемых как существующие отдельно от нашего мира, единственная цель которых –быть точными, недвусмысленными (два объекта могут быть равными или разными, связанными друг с другом или нет; операция дает точный результат, и т.д.). Математика разделена на много областей: концепций или объектов изучения, которые можно формально определить как разнообразие (аксиоматичных) теорий. Каждая теория изучает какую-либо предположительно фиксированную систему (мир математических объектов), вид которой изначально определен (выбран из всех возможных математических систем) с помощью математического описания, которое называется <i>основой </i> этой теории.

<div class="p"><!----></div>
Некоторые теории можно расположить в виде иерархий , где одни теории могут быть основой для других. Например, основы нескольких теорий могут иметь общую часть, которая представляет собой более простую теорию, модификации которой применимы к ним всем. 

<div class="p"><!----></div>
Наука, изучающая основы математики как единого целого, была разработана как область математики под названием  <i>математическая логика</i>,Она состоит (как и любая другая область) из определений и теорем, описывающих системы объектов (общая форма объектов, теории и их соответствующие, возможно, изученные системы), отвечая на многие философские вопросы и создавая общую структуру для всей математики. 

<div class="p"><!----></div>
Во-первых и всегда, основы математики или теории –это то, что о них известно или выборочно принято. Затем изучение продвигается вперед путем выбора некоторых возможных следствий этой теории : новых понятий и информации вытекающих из предыдущей основы и присоединяющихся к ней, чтобы сформировать следующую основу. Другие варианты, не выбранные в данный момент, могут быть выбраны позднее, так как основа, на которой они могут возникнуть, продолжает существовать.  Таким образом, совокупность возможных следствий уже образует некую минимальную &laquo;реальность&raquo;  и можно сказать, что они ее исследуют, пока не возникнет возможность продемонстрировать нечто лучшее (см. Теорему полноты, представленную в Части 3). 
Фундаментальная работа состоит в том, чтобы, исходя из простой первоначальной основы, разработать более полную основу, которая наилучшим образом облегчает создание дальнейших интересных следствий данной теории. 

<div class="p"><!----></div>
Несмотря на элементарность математических объектов, основы математики  (где основа каждой основы, в отличие от обычных математических работ, продвигается вперед от предполагаемой основы),оказываются достаточно сложными (хотя и не настолько, как физическая «теория всего»):будучи сами по себе одной из ветвей математики, укорененной на них, основы математики образуют не стартовую точку, а широкую движущую силу, петлей приблизительно соединяющуюся с самой собой, образованную из более или менее сложных этапов.  

<div class="p"><!----></div>
(Это напоминает то, как в словарях дается определение каждого слова с помощью других слов, или это напоминает другую науку конечных систем: компьютерное программирование. Действительно, компьютерами можно просто пользоваться, зная, чтó ты делаешь, но не зная, почему это работает.  Их работа основана на программном обеспечении, которое было написано на некоем языке, потом скомпилировано другим программным обеспечением, а также на аппаратном обеспечении («железе») и процессоре, которые были сконструированы и изготовлены при помощи компьютеров. И это гораздо лучше, чем обстояло дело при зарождении этой области науки.)

<div class="p"><!----></div>
И все же эта петля является истинной основой математики, поскольку ее части богаты полезными понятиями для разнообразных областей математики. 
В ней доминируют две теории: 

<div class="p"><!----></div>
<b>Теория множеств</b> изучает вселенную &laquo;всех математических объектов&raquo;,от простейших до самых сложных, таких как бесконечные системы.Но в деталях она имеет неограниченное разнообразие возможных вариантов (не всегда одинаковых).

<div class="p"><!----></div>
 <b>Теория моделей</b> это общая теория теорий (описывающая их формализм как систему символов) (миров) объектов, которые они могут описывать, называемые их <i>моделями</i> (их возможными интерпретациями). Ее дополняет теория доказательств (описывающая правила доказательств). Она по существу уникальна, она придает ясное и окончательное значение понятиям теории и теоремы в каждой теории.  

<div class="p"><!----></div>
Каждая из них –это естественная структура, позволяющая дать формальное представление другой: теория моделей описывает каждую теорию множеств как аксиоматическую теорию, а также и ее саму лучше представить как следствие теории множеств (построение теорий и моделей как сложных объектов в теории множеств)чем как отдельную теорию. Таким образом, теория множеств –это одновременно и базовая структура для теории моделей, и ее объект изучения (но эти две копии теории множеств нельзя путать, даже если они построены по одним и тем же правилам). Но завершение этих формальных представлений потребует много времени. 

<div class="p"><!----></div>
 Специалисты по основам математики выбрали аксиоматическую теорию множеств Цермело-Френкеля (сокращенно ЦФ; или ЦФВ - Система Цермело-Френкеля с аксиомой выбора) как мощную теорию в увеличенном круге основания, которая может доказать многие сложные пропозиции или их недоказуемость. 

<div class="p"><!----></div>
Математика начинается с введения некоторых простых понятий (круге основания), которые, на первый взгляд, не основаны на других. Естественно начать с теории множеств, которая не полностью формализована как аксиоматическая теория. 
Ее обычно представляют как популяризированную или НЕЯВНУЮ версию ЦФВ, признавая ее аксиомы как необходимые или очевидные.

<div class="p"><!----></div>
Но ЦФВ не является идеальным стартовым ориентиром для начал математики. Ее аксиомы менее НАТУРАЛЬНЫ, чем кажутся; полное обоснование их существования тоньше, чем то, что они просто результаты интуиции, исторически выбранные для связности и удобства результирующей системы. Но аксиомы только приносят свои требования в рассматриваемый мир внутри необходимой существующей коллекции теорий моделей, которая придает смысл этим аксиомам. Также, ЦФВ assumes  рассматривает всё как множества, множества множеств и т.д., построенные над пустым множеством. Но обычная математика при разработке на этой основе несколько громоздка и использует много объектов, не рассматриваемых как множества. Поскольку множества могут играть все эти роли, это не обязательно было формализовывать, но это по-прежнему представляет собой расхождение между  &laquo;теорией&raquo; и практикой математики. 

<div class="p"><!----></div>
<h3>1.2. Переменные, множества, функции и операции </h3>
Давайте начнем рассмотрение математики с теории множеств, более непосредственно подходящей для математической практики, имеющей больше понятий и объяснений о контексте основ (теория моделей) и ее основных тонкостей (парадоксов). Начнем с трех понятий (видов объектов): элементов, множеств и функций; и по мере необходимости будем развивать ФОРМАЛЬНОЕ ПРЕДСТАВЛЕНИЕ, вместе с другими понятиями, символами и аксиомами, которые можно рассматривать как примитивные или нет, и которые могут быть необязательными. 

<div class="p"><!----></div>
<br /><i>Константы</i>

<div class="p"><!----></div>
<i>Символ константы </i>  –это символ, обозначающий уникальный объект, который называют ее <i>значением</i>. Примеры: 3, &#216;,  &#x2115;. В английском языке это имена собственные и названия, начинающиеся с определенного артикля (в единственном числе без дополнения). 

<div class="p"><!----></div>
<br /><i>Свободные и связанные переменные</i>

<div class="p"><!----></div>
<i>Символ переменной</i> (или просто <i>переменная</i>)–это символ без закрепленной интерпретации. Каждая возможная интерпретация придает ему определенное значение и таким образом рассматривает его как константу.

<div class="p"><!----></div>
Можно представить себе это как нечто, находящееся в пределах коробки. Если смотреть изнутри коробки, это можно использовать как константу : ее называют <i>свободной </i> или <i>фиксированной</i>.  Если смотреть снаружи, ее возможные значения рассматриваются во всем своем разнообразии: такую переменную называют <i>связанной</i>. 

<div class="p"><!----></div>
<br /><i>Диапазоны и множества</i>

<div class="p"><!----></div>
<i>Диапазон</i> переменной–это ее значение, когда она рассматривается как связанная: это знание (определение) всех ее возможных или допустимых значений, которые называются <i>элементами  </i> этого диапазона. Любой диапазон переменной называется <i>множеством</i>. (Это &laquo;знание&raquo; в отличие от человеческой мысли, - абстрактное целое, которое может включать бесконечные количества объектов; элементы рассматриваются в массе: неупорядоченными, без учета контекста).
Переменная имеет диапазон, если его можно связать, т.е. когда возможен обзор, охватывающий все ее возможные значения. 

<div class="p"><!----></div>
Говорят, что переменная <i>ИЗМЕНЯЕТСЯ В ПРЕДЕЛАХ/ЗАКЛЮЧАЕТСЯ В ПРЕДЕЛАХ/ОХВАТЫВАЕТ</i> множества, если она связана с этим множеством как с диапазоном.
В данном диапазоне может быть представлено любое количество переменных, независимо друг от друга и от других переменных. 

<div class="p"><!----></div>
Кантор определял множество как &laquo;<i>соединение в единое целое хорошо различимых предметов нашего созерцания или нашего мышления</i>&raquo;. Он объяснял Дедекинду : &laquo;<i>Если совокупность элементов множественности можно представить как &laquo;существующие одновременно&raquo;, так, чтобы их можно было воспринимать как &laquo;единый объект&raquo; (или &laquo;завершенный объект&raquo;),  я называю это непротиворечивой множественностью или &laquo;множеством&raquo;.</i>&raquo; (Мы выразили эту &laquo;множественность&raquo; как множественность значений переменной).

<div class="p"><!----></div>
Он описал противоположный случай как &laquo;<i>противоречивую множественность</i>&raquo; где &laquo;<i>признание совместного существования всех ее элементов ведет к противоречию</i>&raquo;. Но непротиворечивости не достаточно для того, чтобы дать общее определение множеств: непротиворечивость не означает истинности (противоположное этому заявление может быть истинно, но недоказуемо); факты непротиворечивости сами представляют собой распространенный случай недоказуемых истин; и две множественности, которые отдельно друг от друга непротиворечивы, могут противоречить друг другу (<a href="http://rationalwiki.org/wiki/Omnipotence_paradox">Парадокс всемогущества</a>). 

<div class="p"><!----></div>
Систематическое переименование связанной переменной во всем объеме «коробки» в другой символ, не используемый в том же контексте  (той же коробке), с тем же диапазоном, не меняет значения целого. На практике, одна и та же буква может обозначать несколько отдельных связанных переменных (у которых отдельные коробки), которые могут принимать различные значения, так как их никогда не интерпретируют (свободно) вместе, и поэтому они не сравнимы. Обычный язык постоянно это делает, используя небольшое количество переменных символов (&laquo;он&raquo;, &laquo;она&raquo;, &laquo;оно&raquo;...)

<div class="p"><!----></div>
<br /><i>Функции</i>

<div class="p"><!----></div>
<i>Функция</i>–это любой объект <i>f</i> ведущий себя как переменная зависящая от другой переменной с диапазоном, обозначенным Dom f, называемого ее <i>аргументом</i>,  диапазон которого обозначается символом <span class="roman">Dom</span>&nbsp;<i>f</i>  : когда этот аргумент фиксированный (обозначенный как символ  <i>x</i>), <i>f</i> превращается в константу (обозначена как <i>f</i>(<i>x</i>)). Другими словами, <i>f</i> содержит следующие данные:
<ul><li>Множество, называемое <i>область определения</i> <i>f</i>, обозначено как <span class="roman">Dom</span>&nbsp;<i>f</i>
</li><li>Для каждого элемента <i>x</i> из области определения <span class="roman">Dom</span>&nbsp;<i>f</i>, объект <i>f</i>(<i>x</i>) называют <i>ИЗОБРАЖЕНИЕМ/ПРЕДСТАВЛЕНИЕМ <i>x</i> от <i>f</i></i> или <i>значением  <i>f</i> при <i>x</i></i>. </li></ul>

<div class="p"><!----></div>
<br /><i>Операции</i>

<div class="p"><!----></div>
<i>Операция </i>–это обобщенная функция к случаю конечного списка аргументов (переменных с данными относительными диапазонами), дающая результат (значение), когда все аргументы фиксированные.  Число <i>n</i> аргументов называют его <i>арностью </i>; операция называется  <i><i>n</i>-арной</i>. Ее называют  <i>унарной,</i> если <i>n</i>=1 (это функция), <i>бинарной</i> если <i>n</i>=2, <i>тернарной</i> если <i>n</i>=3... Нульарные операции бесполезны, поскольку их можно заменить их значением; мы увидим, как создавать операции с арностью  &gt;  1 посредством функций. 

<div class="p"><!----></div>
Значение бинарной операции <i>f</i> над ее фиксированными аргументами называется (со значениями, придаваемыми)) <i>x</i> и <i>y</i>, обозначается <i>f</i>(<i>x</i>,<i>y</i>). 
Так что, вместо символов, аргументы представлены левым и правым положением в скобках, которые заполняются любым выражением, которое придает им желаемое значение. 

<div class="p"><!----></div>
<h3>1.3. Структура теорий: объекты, метаобъекты, типы и структуры</h3>

<div class="p"><!----></div>
Основание теории имеет два уровня. Во-первых, мы должны установить <i>формальное представление</i> которое будет содержать теорию: логическую структуру, или грамматику. Это определяет, каким образом можно выразить содержание теории и вывести ее следствия. Вначале, мы введем только 2 из этих потенциально полезных видов формального представления. Теории в формальном представлении <i>логики первого порядка</i> будут называться здесь <i>генерическими теориями</i> ; особое формальное представление будет введено для теории множеств. В третьей части будут представлены другие виды формального представления. 

<div class="p"><!----></div>
Каждая теория имеет свои собственные <i>понятия</i>, обычно обозначаемые общими названиями. Понятие –это вид переменных, допускаемых в языке теории, которые в каждой модели (интерпретации теории) относятся к диапазону возможных значений этого вида переменной. 
<i>Объект</i> теории в модели –это любой допускаемый элемент любого понятия (возможное значение любой переменной) теории в этой модели. 
разные возможные формальные представления, кроме представления в нашей теории множеств, будут управлять переменными следующим образом: их единственными принятыми понятиями будут <i>типы</i> их количество обычно является конечным), классифицирующие и переменные, и объекты. Каждый объект будет принадлежать только к одному типу - типу переменных, которые могут давать ему название. 

<div class="p"><!----></div>
 В имплицитной структуре теории моделей мы обсудим несколько теорий <i>T</i> и их возможные модели <i>M</i> (системы, описываемые <i>T</i>). Итак, переменные <i>T</i> и  <i>M</i> –это переменные теории моделей, соответственно принадлежащие ее понятиям &laquo;теория&raquo; и &laquo;модель&raquo;. Но когда мы будем концентрироваться на одной теории (множеств) с предположительно фиксированной моделью, эти переменные будут фиксированными и, таким образом, исчезнут вместе с понятиями, к которым они относятся, так как станут имплицитными. Из теории моделей, структура будут сведена к <i>теории одной модели</i>. 
 Различные версии теории (одной) модели соответствуют различным формальным представлениям для теорий, но по-прежнему имеют много сходств (общих понятий). (Мы не будем здесь указывать формальные представления, которыми выражены сами теория моделей и теория одной модели.)

<div class="p"><!----></div>
Примеры понятий из различных теорий:

<div class="p"><!----></div>
<br />
<table>
<tr><td align="center"><b>Теория</b>&nbsp;&nbsp;&nbsp;</td><td align="left"><b>Виды объектов (понятии))</b><!--hbox--></td></tr>
<tr><td align="center">Общая теория &nbsp;&nbsp;&nbsp;</td><td align="left">чистые элементы классифицированные по типам<!--hbox--></td></tr>
<tr><td align="center">Теория наборов &nbsp;&nbsp;&nbsp;</td><td align="left">Элементы, комплекты, функции, операции, отношения, tuples ...<!--hbox--></td></tr>
<tr><td align="center">Теория моделей &nbsp;&nbsp;&nbsp;</td><td align="left">Теории, системы и их компоненты (см. ниже)<!--hbox--></td></tr>
<tr><td align="center">Теория одной модели &nbsp;&nbsp;&nbsp;</td><td align="left">объекты, символы, типы, структуры (операторы, предикаты), формулы...<!--hbox--></td></tr>
<tr><td align="center">Арифметика &nbsp;&nbsp;&nbsp;</td><td align="left">Натуральные числа<!--hbox--></td></tr>
<tr><td align="center">Линейная алгебра &nbsp;&nbsp;&nbsp;</td><td align="left">Векторы, скаляры...<!--hbox--></td></tr>
<tr><td align="center">Геометрия &nbsp;&nbsp;&nbsp;</td><td align="left">Точки, линии, круги...<!--hbox--></td></tr></table>

<div class="p"><!----></div>
<br />Вся система изготовлена ​​из данных теории  <i>T</i> и системы <i>M</i> что является моделью <i>T</i>, представляет собой модель [<i>T</i>,<i>M</i>] из теории одной модели <i>T</i><sub>1</sub>. Понятия теории одной модели, обычно интерпретируется в [<i>T</i>,<i>M</i>],классифицирует компоненты <i>T</i> (&laquo;тип&raquo;, &laquo;символ&raquo;, &laquo;формула&raquo;...), а те, из <i>M</i> (&laquo;объект&raquo; , и инструменты для интерпретации <i>T</i> там). Но те же представления о теории одной модели можно интерпретировать в своём другом моделе [<i>T</i><sub>1</sub>,[<i>T</i>,<i>M</i>]],которая будет выражаться, поставив префикс мета-на них. 

<div class="p"><!----></div>
По понятии своего &laquo;обьекта&raquo;,теория одной модели отличает объекты <i>T</i> в <i>M</i> среди своих объектов в [<i>T</i>,<i>M</i>], которые являются мета-объектами. Таким образом, каждый объект будет мета-объектом. Однако на практике мы будем делать исключение и называть <i>мета-объектами</i> только то, что не является объектами. . 

<div class="p"><!----></div>
В отличие от теории множеств, теория одной модели дает диапазон каждой переменной своей изученной теории. Однако каждый диапазон, то есть понятие, является только мета-объектом.

<div class="p"><!----></div>
Как только зафиксировано формальное представление, приходит очередь содержания основ теории, которое является отличительной чертой теории и пытается определить предполагаемый вид ее моделей и их различные концепции (вокабуляр). Эта основа теории состоит из (математически условного, но интуитивно сконструированного) тройного списка данных, структурированных в виде 3 слоев:

<div class="p"><!----></div>
1) Список <i>абстрактных типов</i> цель которых – установить типы объектов;

<div class="p"><!----></div>
2)<i>Язык </i> : список <i>символов структуры</i>, цель которых –установить отношения объектов к конкретным типам;

<div class="p"><!----></div>
3)Список формул, называемых  <i>аксиомами</i>  выбранных из множества всех возможных закрытых формул, т.е 1.4.).

<div class="p"><!----></div>
Вместо того,чтобы быть описанным c помошью теории одной модели, та же система, [<i>T</i>,<i>M</i>]может быть понята как переведено на теории множеств, представляющая компоненты из <i>T</i>компонентами теории множеств в то время как только те из <i>M</i> становятся объектами, следующим образом.
Переменные из <i>T</i>сохраняются в качестве переменных теории множеств. Каждый абстрактный тип становится свободной переменной, значением которой является набор по имени <i>интерпретированный тип</i>. 
Точнее, используя стандартную форму перевода, которая подходит для любой генерической теории: все объекты будут переведены в чистые элементы (в отличие от обычной точки зрения, что геометрия определяет линии как множества точек). 

<div class="p"><!----></div>
Абстрактные типы и структурные символы все переводятся как свободные переменные, которые остаются свободными, пока модель остается фиксированной. Их значения являются основными компонентами модели, компонентами, которые определяют ее. 
Это объединяет все теории (арифметика, геометрия ...) и их разнообразие возможных моделей, в той же теории множеств с фиксированной модели  также называется как <i>вселенная</i>). 

<div class="p"><!----></div>
<h3>1.4. Структуры и выражения</h3>

<div class="p"><!----></div>
<br /><i>Структуры</i>

<div class="p"><!----></div>
Структуры (и, таким образом структурные символы) могут быть 2 видов: операторы и предикаты. Как переменная теории множеств, значение каждого символа оператора является оператором <i>оператор</i>, т.е. операция, где диапазон каждого аргумента представляет собой тип, и значения относятся к одному типу; арность (или список аргументов предоставленных как зона вокруг символа), абстрактный тип каждого аргумента и тип значений даны с каждым символом. Нульарный оператор –это постоянный символ, напрямую называющий фиксированный объект. Но тем не менее это свободная переменная теории множеств. Унарный оператор, т.е. функция, будет называться <i>функтор</i>.

<div class="p"><!----></div>
Модель завершается стандартным специальным типом: типом <i>булевых</i> выражений, состоящих из обоих элементов &laquo;истинно&raquo; (1) and &laquo;ложно&raquo; (0). Переменная этого типа (за пределами теории) называется <i>Булева переменная</i>. Ее добавление к списку типов обобщает операторы до пара-операторов<i>пара-операторов</i>. A <i>Связка</i>– это пара-оператор с только булевыми аргументами и значениями. <i>Предикат</i> –это пара-оператор с одним или более аргументами, среди которых нет булевых, и с булевыми значениями. <i>Структура</i>–это оператор или предикат. 

<div class="p"><!----></div>
Структуры (интерпретация символов с языка теории в моделе) дают каждому элементу любого типа свои роли возможных сложных объектов. В теории множеств, роль множеств дано бинарным предикатом  &#8712;  для любого элемента:
<i>x</i> и любого множества  <i>E</i>, утверждение, что (значение) <i>x</i> является возможным значением переменной с диапазона <i>E</i>, написана <i>x</i> &#8712; <i>E</i> (которая гласит, что : <i>x</i> есть в <i>E</i>,или или элемент из <i>E</i>).
ZFC теоряи множеств определяется как общая теория с одним типом  &laquo;множества&raquo;,только одной структуры символа   &#8712; , и аксиомой.Но наша теория множеств не будет общим, и будет включать в себя другие символы способствуя приданию их роли наборам, функциям и другим типов объектов.

<div class="p"><!----></div>
функции играют свою роль с помощью функтора <span class="roman">Dom</span>&nbsp; (задавая их области) и <i>оценщика функции </i>,бинарным оператором давая значение <i>f</i>(<i>x</i>) любой функции <i>f</i> в любой элемент  <i>x</i> из <span class="roman">Dom</span>&nbsp;<i>f</i>.

<div class="p"><!----></div>
Теория одной модели, формализованная как генерическая теория, будет придавать &laquo;типам&raquo;  двойную роль абстрактных и интерпретированных типов.  Также, те же мета-объекты могли бы играть роли структурных символов и структур, за исключением того, что понятие &laquo;структуры&raquo; будет включать другие операции между типами, помимо операций, обозначенных символами (мы не можем допустить их &laquo;все&raquo; независимо от внешней вселенной, из которой они взяты, которая не релевантна здесь).

<div class="p"><!----></div>
<br /><i>Terms and formulas</i>

<div class="p"><!----></div>
Для любого данного списка абстрактных типов и символов структуры теории, a <i>термин</i> является конечной системой вхождений символов, с целью назначить объектам (его значение) как только модель и значения свободных переменных зафиксированы. (Вхождение символа –это его появление где-то, например, «x+x» имеет два вхождения х и одно вхождение +.). Мы называем <i>формулой</i> систему, сходную с термом, но без булевых значений. <i>Выражение</i> может быть термом или формулой. 

<div class="p"><!----></div>
Выражения могут использовать следующие виды символов :
<ul><li>Переменные
</li><li>Структурные символы (операторы и предикаты) из языка
</li><li>Один ровенственный символ по одному типу (предикат с 2 аргументами этого самого типа)оскорбительно все обозначается =,интерпретируются стандартным образом.
</li><li>Связки
</li><li>Связующие: общая теория использует только обе кванторы (&#8704; и &#8707;, см. 1.8.),но у нашей теории множеств будет больше (см. п. 1.7.).
</li></ul>

<div class="p"><!----></div>
Выражения строятся последовательно, каждое как данные (вхождение) символа, называемого его корнем, и список ранее построенных выражений (и, возможно, переменных символов). Этот корень определяет тип значений (и таким образом проводит различие между термами и формулами) и формат этого списка (количество пунктов и тип каждого из них). Для символа пара-оператора, этот формат задается списком его аргументов. 

<div class="p"><!----></div>
Первые термы –это термы, сведенные к вхождению символа константы или переменной, они называются <i>атомные термы</i>. Булевы константы 1 и 0 (нульарные связки) – это первые формулы.

<div class="p"><!----></div>
Для других символов требуется непустой список, таким образом, им нужны условные знаки, чтобы его представить. Большая часть символов бинарных пара-операторов выглядят как условный знак между двумя аргументами (добавление обозначается x+y вместо первоначального формата операций  +(x,y)); другие (умножение, степень) обозначаются неявно, без использования условного обозначения. 
Другие символы выражаются несколькими условными знаками, устанавливающими границы пунктов списка. Скобки могут или компоновать буквенные изображения символов как интерпретатор функции, или использоваться для того, чтобы выделить под-выражения и их соответствующие корни, как в (x+y)n.

<div class="p"><!----></div>
Выражение <i>закрыто</i>, если оно не имеет свободной переменной (все переменные связаны с связками см. 1,7), так что его значение зависит только от системы объектов (модели) интерпретирующей типы и символы теории. Список<i>аксиом</i>,  выбранный из множества замкнутых формул, выражает необходимые свойства моделей, т.е. выбор систем, где все эти аксиомы истинны, чтобы они могли быть&laquo;возможными моделями&raquo;теории, исключив из названия &laquo;модели&raquo; любую систему, где аксиома не верна.

<div class="p"><!----></div>
<br /><i>Структуры определённые выражениями; классы</i>

<div class="p"><!----></div>
В теории одной модели <i>структура </i> (оператор или предикат) это любая операция между типами объектов (например, объекты, названные структурными символами), определяемая выражением (термином или формулой) и списком выбранных свободных переменных чтобы связать в роли аргументов. Эта структура зависит от других переменных оставшихся свободными, называемых ее <i>параметрами</i> (в то время как связанные переменные внутри выражения, невидимые снаружи, здесь не учитываются). <i>Класс </i> унарный предикат рассматриваемый как множество объектов, для которых он истинный.

<div class="p"><!----></div>
 Давайте расширим язык теории, введя один (или более) структурный символ. Если  &laquo;константы&raquo;  (то есть, нульарные константы ) ведут себя, как свободные переменные, их роль могут выполнять обычные переменные теории. Это можно использовать, чтобы назвать структуру, определяемую выражением (или одним из конечного списка выражений), тем самым сокращая это выражение. В этом случае, такой символ может быть связан (совпасть по диапазону со структурами, которые являются его предполагаемыми значениями) путем связывания параметров этого выражения. Но в других случаях (символы с ненулевой арностью, могущие представлять любую структуру, даже структуру, не определяемую параметрами), эти символы, как правило, больше не могут быть связанными, поскольку никакая аксиома не может формально заявить, что они совпадают по диапазону со всеми операциями данной арности между данными типами объектов. 

<div class="p"><!----></div>
Назовем <i>инвариантной структурой</i> любую структуру, определяемую без параметров. Каждый символ в языке теории представляет инвариантную структуру (которую он определяет без параметров). Наоборот, инвариантные структуры могут быть названы новыми символами, которые будут добавлены к языку теории, сохраняя ее глубокий смысл (доказуемость, структуры, инвариантные структуры...). Такие правила для разработки теории подробно изложены в п. 3.2.

<div class="p"><!----></div>
<h3>1.5. Связки</h3>

<div class="p"><!----></div>
 Вот наиболее полезные связки в порядке арности <i>n</i>  &gt;  0, по своим свойствам для всех значений логических переменных (заменяемых формулами) <i>A</i>, <i>B</i>, <i>C</i>.

<div class="p"><!----></div>
 <i>n</i>=1 : отрицание &#172; обменивает булевы выражения (&#172;<i>A</i> читается &laquo;не как <i>A</i>&raquo;): 
&#172;1&nbsp;&#8660;&nbsp;0, &#172;0&nbsp;&#8660;&nbsp;1, &#172;(&#172;<i>A</i>)&nbsp;&#8660;&nbsp;<i>A</i>. обозначается также корнем из аргумента (формируя другой символ в том же формате)):   (<i>x</i> &#8800; <i>y</i>)&nbsp;&#8660;&nbsp;&#172;(<i>x</i>=<i>y</i>) (&laquo;<i>x</i> отличается от <i>y</i>&raquo;); <i>x</i> &#8713; <i>E</i>&nbsp;&#8660;&nbsp;&#172;(<i>x</i> &#8712; <i>E</i>) (&laquo;<i>x</i> не принадлежит к <i>E</i>&raquo;). 

<div class="p"><!----></div>
in

<div class="p"><!----></div>
 <i>n</i>=2 :

<div class="p"><!----></div>
&nbsp;&#8743;&nbsp; (и): верно только тогда, когда оба аргумента верны;

<div class="p"><!----></div>
&nbsp;&#8744;&nbsp; (или): верно, за исключением случаев, когда оба аргумента ложны;

<div class="p"><!----></div>
&nbsp;&#8658;&nbsp; : <i>A</i>&nbsp;&#8658;&nbsp;<i>B</i> может быть прочитано как &laquo;A подразумевает B&raquo;, &laquo;<i>A</i> -достаточное условие для <i>B</i>&raquo;, или &laquo;<i>B</i> является необходимым условием <i>A</i>&raquo;, и означает ((&#172;<i>A</i>) &nbsp;&#8744;&nbsp;<i>B</i>). Когда это верно за исключением случаев, когда <i>A</i> истинно, а <i>B</i> is false, ложно, это означает, что если верно <i>A</i>, то <i>B</i> также верно, но в противном случае оно не дает нам информации (будучи истинно).

<div class="p"><!----></div>
Формула (&#172;<i>B</i>&nbsp;&#8658;&nbsp;&#172;<i>A</i>) называется <i>контрапозитивной &nbsp;</i> из (<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>), и эквивалентна ей.

<div class="p"><!----></div>
&nbsp;&#8660;&nbsp; (эквивалент), равенство логических значений: (<i>A</i>&nbsp;&#8660;&nbsp;<i>B</i>)&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>A</i>)). Доказательство что <i>A</i>&nbsp;&#8660;&nbsp;<i>B</i> может быть получено из импликации (<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>), то другой (<i>B</i>&nbsp;&#8658;&nbsp;<i>A</i>), называется его <i>обратное</i>.

<div class="p"><!----></div>
Его отрицание <i>A</i> &#x21CE; <i>B</i> можно также прочитать как отрицание аргумента (<i>A</i>&nbsp;&#8660;&nbsp;&#172;<i>B</i>), либо как &laquo;исключающее или&raquo; ((<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;&#172;(<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)).
Отрицания обменивают различные связки:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#x21CE; (&#172;<i>A</i> &nbsp;&#8743;&nbsp;&#172;<i>B</i>)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#x21CE; (&#172;<i>A</i>&nbsp;&#8744;&nbsp;&#172;<i>B</i>)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"> &#x21CE; (<i>A</i>&nbsp;&#8743;&nbsp;&#172;<i>B</i>)</td></tr></table></td></tr></table>
</td></tr></table>


Это превращает свойства ассоциативности и дистрибутивности в различные формулы:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
((<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8743;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
((<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)&nbsp;&#8744;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8744;&nbsp;(<i>B</i>&nbsp;&#8744;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8658;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)&nbsp;&#8658;&nbsp;<i>C</i>)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8658;&nbsp;(<i>B</i>&nbsp;&#8744;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8744;&nbsp;<i>C</i>)</td></tr></table></td></tr></table>
</td></tr></table>



<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8744;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)&nbsp;&#8744;&nbsp;(<i>A</i>&nbsp;&#8743;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8744;&nbsp;(<i>B</i>&nbsp;&#8743;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;(<i>A</i>&nbsp;&#8744;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8658;&nbsp;(<i>B</i>&nbsp;&#8743;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;(<i>A</i>&nbsp;&#8658;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
((<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)&nbsp;&#8658;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>C</i>)&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8658;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8744;&nbsp;<i>C</i>)&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8658;&nbsp;(<i>A</i> &nbsp;&#8743;&nbsp;<i>C</i>))</td></tr></table></td></tr></table>
</td></tr></table>


<i>n</i> &#8805; 3 : последовательности &nbsp;&#8743;&nbsp; (конъюнкции) такие как (<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>&nbsp;&#8743;&nbsp;<i>C</i>), а &nbsp;&#8744;&nbsp; (дизъюнкции) такие как (<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>&nbsp;&#8744;&nbsp;<i>C</i>) получают путем удаления скобок благодаря ассоциативности. Утверждение конъюнкции равнозначного утверждению всех его компонентов. Кроме того, любая последовательность формул связанных  &nbsp;&#8660;&nbsp; и &nbsp;&#8658;&nbsp; сокращает последовательность требований (связанных &nbsp;&#8743;&nbsp;) каждого звена между соседними формулам:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
0</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8658;&nbsp;<i>A</i>&nbsp;&#8658;&nbsp;<i>A</i>&nbsp;&#8658;&nbsp;1</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(&#172;<i>A</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8658;&nbsp;0)&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8660;&nbsp;0)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8658;&nbsp;<i>C</i>))&nbsp;&#8658;&nbsp;(<i>A</i>&nbsp;&#8658;&nbsp;<i>C</i>)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8660;&nbsp;<i>B</i>&nbsp;&#8660;&nbsp;<i>C</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;((<i>A</i>&nbsp;&#8660;&nbsp;<i>B</i>)&nbsp;&#8743;&nbsp;(<i>B</i>&nbsp;&#8660;&nbsp;<i>C</i>))&nbsp;&#8658;&nbsp;(<i>A</i>&nbsp;&#8660;&nbsp;<i>C</i>)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>A</i>&nbsp;&#8743;&nbsp;<i>A</i>)&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8743;&nbsp;1)</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;<i>A</i>&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8744;&nbsp;<i>A</i>)&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8744;&nbsp;0)&nbsp;&#8660;&nbsp;(1&nbsp;&#8658;&nbsp;<i>A</i>)&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8660;&nbsp;1)</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(<i>B</i>&nbsp;&#8743;&nbsp;<i>A</i>)&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8743;&nbsp;<i>B</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&#8660;&nbsp;(<i>A</i>&nbsp;&#8743;&nbsp;(<i>A</i>&nbsp;&#8658;&nbsp;<i>B</i>))&nbsp;&#8658;&nbsp;<i>B</i>&nbsp;&#8658;&nbsp;(<i>A</i>&nbsp;&#8744;&nbsp;<i>B</i>)&nbsp;&#8660;&nbsp;(<i>B</i>&nbsp;&#8744;&nbsp;<i>A</i>)</td></tr></table></td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
<i>Аксиомы равенства</i>

<div class="p"><!----></div>
для любого функтора <i>T</i> и объектов <i>x</i>, <i>y</i> (что может символизировать термы с параметрами), 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<i>x</i>=<i>y</i>&nbsp;&#8658;&nbsp;<i>T</i>(<i>x</i>)=<i>T</i>(<i>y</i>)</td></tr></table>
</td></tr></table>


Аналогично для любого унарного предиката <i>A</i> мы имеем <i>x</i>=<i>y</i>&nbsp;&#8658;&nbsp;(<i>A</i>(<i>x</i>)&nbsp;&#8660;&nbsp;<i>A</i>(<i>y</i>)). 

<div class="p"><!----></div>
Таким образом, равенство между термами <i>x</i>=<i>y</i> позволяет заменять любое вхождение (я) <i>x</i> на <i>y</i> в любом выражении без влияния на результат. Это относится, в частности, к случаям, когда символ определен термом: они равны, и взаимозаменяемы в любом выражении.
Также аксиомы и другие законы выражаются с использованием переменных символов заменяемых термами  в их использовании.

<div class="p"><!----></div>
<h3>1.6. Классы в теории множеств</h3>

<div class="p"><!----></div>
<br /><i>Теория множеств в создании цикла</i>

<div class="p"><!----></div>
Теория одной модели не может быть полностью формализована в логике первого порядка (требуется аксиома второго порядка чтобы исключить бесконечно большие &laquo;выражения&raquo; и &laquo;доказательства &raquo;, см. часть 3), но только при переводе в теорию множеств. Как компоненты ее модели [<i>T</i>, <i>M</i>] названы там свободными переменными, их изменчивость создает это множественно-теоретическое выражение теории моделей (общий обзор основ математики).

<div class="p"><!----></div>
Теперь пусть <i>T</i><sub>0</sub> будет множество теоретическим выражением внешней теории, что соответствует <i>T</i> (определяется по тем же правилам): каждый компонент <i>T</i><sub>0</sub> переводится в <i>T</i> преобразованием его в замкнутый терм (по-прежнему теории множеств) определяя его образ в <i>T</i>. 
Таким образом, модель <i>M</i> из <i>T</i> косвенно является также моделью из <i>T</i><sub>0</sub>. 

<div class="p"><!----></div>
Но мы выберем теории <i>T</i> как формализацию теории множеств (переведенную как родовая теории методом объясненным в 1.8 и 1.9), интерпретируя его концепции в <i>M</i>. Таким образом наше выше установленное использование теоретической концепции множество во внешней вселенной необходимо будет отличить от него путем добавления префикса «мета-» .

<div class="p"><!----></div>
теоретические концепции множеств могут быть хорошо отражены интерпретацией их мета-множеств, но их не следует путать. Вместо стандартного представления всех объектов в виде чистых мета-элементов, роль множеств  обычно будут играть мета- множества из тех же элементов (аналогично и для функций), позволяя любому множеству <i>E</i> быть классом (определенным с <i>x</i> &#8712; <i>E</i>  аргументом <i>x</i> и параметром <i>E</i>), в то время как любой класс является мета-множеством объектов. Но некоторые мета-множества объектов, будучи неопределимыми, не являются классами; и некоторые классы, такие как вселенная (класс всех объектов, определяются путем 1), не являются множествами. 

<div class="p"><!----></div>
<br /><i>Определенность классов</i>

<div class="p"><!----></div>
Классы являются очень общим видом понятий, которые заменят типы для выражения теории множеств. Действительно, все объекты должны быть включены в качестве &laquo;элементов&raquo; которые могут принадлежать множествам (чтобы избежать бесконечного деления на множества элементов, множества, функции, смешанные множества...). Таким образом, понятия множеств и функций будут представлять собой классами названные символы: множество = &laquo;представляет собой множество&raquo;, <span class="roman">Fnc</span>
= &laquo;функция&raquo;.

<div class="p"><!----></div>
(Для этого мы могли бы сохранить 3 типа, где каждое множество будет включено дважды, как множество и элемент, определенные функтором из множеств к элементам. И то же самое для функций. но этой идеи все равно недостаточно для нашей теории множеств которой потребуется больше классов как понятий)

<div class="p"><!----></div>
В общих теориях, синтаксическая коррекция выражения (что подразумевается в понятии &laquo;выражения&raquo;) гарантирует, что оно примет определенное значение, для всех данных в модели с фиксированной системой значений ее свободных переменных в этой модели. Но в теории множеств, это по-прежнему может зависеть от ее свободных переменных. Таким образом, структура или выражение &#120016; будет названо <i>определенной</i> когда он на самом деле принимает значение для данных значений своих аргументов в модели. Это определенное состояние &#120016; само по себе является определенным предикатом (выраженным формулой) <i>d</i>&#120016;, с теми же свободными переменными. Выражения должны использоваться только, где они определены, что и будет сделано естественно. 

<div class="p"><!----></div>
Классы определяются определенными одноместными предикатами. Мета-область любой унарной структуры &#120016;, это класс определенный <i>d</i>&#120016;, с теми же аргументами и параметрами, и называется его <i>классом определенности.</i>.

<div class="p"><!----></div>
Определенное состояние (<i>x</i> &#8712; <i>E</i>) установлено <span class="roman">Set</span>(<i>E</i>)). Состояние оценщика функции  <i>f</i>(<i>x</i>) это (<span class="roman">Fnc</span>(<i>f</i>)&nbsp;&#8743;&nbsp;<i>x</i> &#8712; <span class="roman">Dom</span>&nbsp;<i>f</i>). 
Но определенность последней формулы должна быть объяснена следующим образом.

<div class="p"><!----></div>
<br /><i>Расширенные определенности</i>

<div class="p"><!----></div>
теория с частично определенной структурой может быть формализована (переведена) как теория с одним типом и везде определенными структурами, сохраняя нетронутыми все выражения и их значения, где они определенные: модели переводятся в одном направлении, путем придания условных значений неопределенным структурам (например, постоянное значение), а в обратном направлении, путем игнорирования этих значений. Таким образом, выражение с неопределенным подвыражением могут быть признано определенным, если его значение не зависит от этих дополнительных значений.

<div class="p"><!----></div>
Для всех предикатов &#120016; и &#120017;, давайте придадим &#120016;&nbsp;&#8743;&nbsp;&#120017; и &#120016;&nbsp;&#8658;&nbsp;&#120017; одно и то же условие определенности  (<i>d</i>&#120016;&nbsp;&#8743;&nbsp;(&#120016;&nbsp;&#8658;&nbsp;<i>d</i>&#120017;)) (нарушая для  &#120016;&nbsp;&#8743;&nbsp;&#120017;, симметрию между &#120016; и &#120017;, которую не обязательно восстанавливать). Таким образом, они будут рассматриваться как определенные, если &#120016; ложно и &#120017; не является определенным, с соответствующими значениями 0 и 1.

<div class="p"><!----></div>
Это гарантирует определенность самих условий определенности, а также <i>d</i>&#120016;&nbsp;&#8743;&nbsp;&#120016; и <i>d</i>&#120016;&nbsp;&#8658;&nbsp;&#120016; (соответственно расширеняя &#120016; на 0 и 1 где это не было определенным). 
Формулы &#120016;&nbsp;&#8743;&nbsp;(&#120017;&nbsp;&#8743;&nbsp;&#120018;) и (&#120016;&nbsp;&#8743;&nbsp;&#120017;)&nbsp;&#8743;&nbsp;&#120018;  имеют одно и то же условие определенности (<i>d</i>&#120016;&nbsp;&#8743;&nbsp;(&#120016;&nbsp;&#8658;&nbsp;(<i>d</i>&#120017;&nbsp;&#8743;&nbsp;(&#120017;&nbsp;&#8658;&nbsp;<i>d</i>&#120018;)))).

<div class="p"><!----></div>
Для любого класса &#120016; и любого унарного предиката &#120017; определенного во всех &#120016;, класс определенный (всюду определенным) предикатом (&#120016;&nbsp;&#8743;&nbsp;&#120017;), называется <i>подкласс </i>&#120016;<i> определяемый на</i> &#120017;.

<div class="p"><!----></div>
<h3>1.7. Связанные переменные в теории множеств</h3>

<div class="p"><!----></div>
последний вид символообразующих выражений -  это связки (связывающие символы), которые связывают одну (или более) переменные  (скажем, х) с выражением F, которое использует переменную х в дополнение к переменным символам , которые присутствуют (со значением) снаружи. Такой символ таким образом отделяет &laquo;внутреннее&raquo; подвыражение <i>F</i> с помощью <i>x</i> как свободное, с &laquo;наружи&raquo;
где <i>x</i> связан. Выражение <i>закрыто </i> если все его переменные связаны (содержатся связками).

<div class="p"><!----></div>
Таким образом, он принимает в качестве данных, символ  <i>x</i>  и выражение <i>F</i>,  и придает значение в зависимости от структуры, с аргументом <i>x</i>, определяемым  <i>F</i>. Это значение не может записывать всю структуру (которая не является объектом), но дает информацию от нее. 
Точный синтаксис отличается в теории множеств и в общей теории, которые управляют диапазонами по-разному.
В общих теориях, диапазоны - это типы, неявные данные связывающих символов. Но в теории множеств, диапазон связанной переменной представляет собой множество, объект, заданный в качестве аргумента связки (как значение терма, который не использует <i>x</i>), в дополнение к вышеуказанным данным. 

<div class="p"><!----></div>
Давайте рассмотрим основные связки в теории множеств.

<div class="p"><!----></div>
<br /><i>Определения функций термами</i>

<div class="p"><!----></div>
<i>Определитель функции</i> (&nbsp; &#8715; &nbsp; &#x21A6; &nbsp;) связывает переменную <i>x</i> с диапазоном <i>E</i> на терме сокращенно обозначенным как <i>t</i>(<i>x</i>) (с возможными неявными параметрами), соблюдая синтаксис (<i>E</i> &#8715; <i>x</i> &#x21A6; <i>t</i>(<i>x</i>)), иногда сокращенно обозначается как (<i>x</i> &#x21A6; <i>t</i>(<i>x</i>))  когда <i>E</i> определяется контекстом. Определенный, если <i>t</i>(<i>x</i>) является определенным для всех <i>x</i> из <i>E</i>, он принимает функтор определяемый <i>t</i> и ограничивает его класс определенности до <i>E</i>, чтобы дать его как функцию с областью <i>E</i>. Этот перевод с функтора на функции, приблизительно переворачивает перевод, сделанный другим определителем функции (от функций к их роли определителей функторов в множествах).

<div class="p"><!----></div>
Другие понятия будут определены как классы объектов с помощью инструментов перевода объекта в его роль, и наоборот. Для любого вида мета-объектов, играющих роль объектов (которые можно опосредованно использовать в выражениях в качестве объектов: класс как множество...), теория множеств обогатится инструментами которые позволят прямо представить их как объекты. Существующие обьекты (множества или функции) могут играть новые роли, предлагая свои инструменты новым объектам. Таким образом, единственные необходимые переводы между объектами играющими одну и ту же роль, свяжут различные полезные представления нового объекта с помощью старых.

<div class="p"><!----></div>
<br /><i>Формализация операций и каррирование</i>

<div class="p"><!----></div>
<i>n</i>-арные операции выступающие в качестве <i>n</i>-арных операторов между <i>n</i> множествами, оформляются:
<ul><li><i>n</i> функторами области (имеющими мало практической пользы);
</li><li>an (<i>n</i> + 1)-арной оценщиком, с аргументами операции <i>f</i> и ее аргументами <i>x</i><sub>1</sub>,&#8230;,<i>x</i><sub><i>n</i></sub>, написанными <i>f</i>(<i>x</i><sub>1</sub>,&#8230;,<i>x</i><sub><i>n</i></sub>); 
</li><li>определителем операции, связующим <i>n</i> переменные с их соответствующими диапазонами на терме. Единственное связывание <i>x</i> к <i>E</i> и <i>y</i> к <i>F</i> на <i>t</i> пишется (<i>E</i> &#8715; <i>x</i>, <i>F</i> &#8715; <i>y</i> &#x21A6; <i>t</i>(<i>x</i>,<i>y</i>)). Мы можем сократить (<i>E</i> &#8715; <i>x</i>, <i>E</i> &#8715; <i>y</i> &#x21A6; <i>t</i>(<i>x</i>,<i>y</i>)) как (<i>E</i> &#8715; <i>x</i>, <i>y</i> &#x21A6; <i>t</i>(<i>x</i>,<i>y</i>)). </li></ul>

<div class="p"><!----></div>
Понятие операции может быть представлено в виде класса функций, следующим образом называемых  <i>каррирование</i>. В качестве операции определителя (связывание <i>n</i> переменных) возьмем последовательность <i>n</i> средств определителя функции (по одному для каждой переменной, которые надо связать); а  подобно  оценщику, <i>n</i> использование оценщика функции:

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
<i>f</i>=(<i>E</i> &#8715; <i>x</i>, <i>F</i> &#8715; <i>y</i> &#x21A6; <i>t</i> (<i>x</i>,<i>y</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 &#8773; (<i>E</i> &#8715; <i>x</i> &#x21A6; (<i>F</i> &#8715; <i>y</i> &#x21A6; <i>t</i>(<i>x</i>,<i>y</i>)))=<i>g</i></td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
<i>f</i>(<i>x</i>,<i>y</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">=<i>g</i>(<i>x</i>)(<i>y</i>)=<i>t</i>(<i>x</i>,<i>y</i>)</td></tr></table></td></tr></table>
</td></tr></table>


промежуточная функция <i>g</i>(<i>x</i>)=(<i>F</i> &#8715; <i>y</i> &#x21A6; <i>t</i>(<i>x</i>,<i>y</i>)) с аргументом  <i>y</i>, рассматривает <i>x</i> as свободный и <i>y</i> связанный.
Но это нарушает симметрию между аргументами и теряет данные <i>F</i> когда <i>E</i>
пусто. Формализация без этих недостатков будет возможна с помощью наборов(2.1.).

<div class="p"><!----></div>
<br /><i>Отношения и множествообразующие символы</i>

<div class="p"><!----></div>
<i>отношение</i> выглядит как операция, но с логическими значениями, действующими в качестве предиката, аргументы которого встречаются в диапазоне множеств. The <i>n</i>-арные отношения оцениваются с (<i>n</i>+1)-арным предикатом, и определяются связывающими  <i>n</i> переменными по формуле. Они могут быть представлены операциями по переводу Логических представлений в объекты. Но есть и другой метод.

<div class="p"><!----></div>
Для любого унарного предиката &#120033; определенного в множестве <i>E</i>, подкласс <i>E</i> определенный &#120033; представляет собой множество (диапазон переменной <i>x</i> введенной в диапазоне <i>E</i>, так что она может быть связанной, из чего мы выбираем случаи удовлетворяющие &#120033;(<i>x</i>)), таким образом, <i>подмножество</i> <i>E</i>, обозначаемое {<i>x</i> &#8712; <i>E</i>&#124;&#120033;(<i>x</i>)} (множество <i>x</i> в <i>E</i> такое, что &#120033;(<i>x</i>)): для всех <i>y</i>,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
<i>y</i> &#8712; {<i>x</i> &#8712; <i>E</i>&#124;&#120033;(<i>x</i>)}&nbsp;&#8660;&nbsp;(<i>y</i> &#8712; <i>E</i>&nbsp;&#8743;&nbsp;&#120033;(<i>y</i>))</td></tr></table>
</td></tr></table>


<i>образователь множества</i> {&nbsp; &#8712; &nbsp;&#124;&nbsp;}, связывающий <i>x</i> к <i>E</i> на &#120033;, будет использован в качестве определяющего для унарных отношений в <i>E</i>, фигурирующих в качестве подмножества <i>F</i> от
<i>E</i>, оцениваемые  &#8712;  как предикаты (<i>x</i> &#8712; <i>F</i>) с аргументом <i>x</i>. Но эти предикаты определены по всей вселенной, давая 0 вне <i>E</i> чьи данные будут потеряны. Это отсутствие оператора <span class="roman">Dom</span>&nbsp; не имеет значения, так как области <i>E</i> как правило, определяются контекстом.

<div class="p"><!----></div>
Как определитель функции (соответственно множествообразующий символ) записывает всю  структуру определенную данным выражением на данном множестве, достаточно задать любой другой связующий символ на том же выражении с той же областью, словно из функтора или унарного предиката добавлен к результату что функция, соответственно множества); <i>n</i>-арные отношения могут быть определены в каррированной форме одним средством образователя множества и <i>n</i>&#8722;1 средств определителя функции.

<div class="p"><!----></div>
<h3>1.8. Кванторы</h3>

<div class="p"><!----></div>
<i>Квантор</i> является связующим символом для формулы, с логическими значениями.
Квантор <i>Q</i> связывающий <i>x</i> с диапазоном <i>E</i> по формуле &#120033;(<i>x</i>), полностью пишется <i>Q</i> <i>x</i> &#8712; <i>E</i>,&#120033;(<i>x</i>). Иногда, область (тип или класс) ставится в качестве индекса: <i>Q</i><sub><i>E</i></sub><i>x</i>,&#120033;(<i>x</i>), или остается неявным (установленным контекстом): <i>Qx</i>,&#120033;(<i>x</i>).
Два основных квантора (под которыми и другие будут определены позже) - это:

<div class="p"><!----></div>
-  <i>Квантор существования</i> &#8707;, который гласит &laquo;There exists <i>x</i> (in...) such that... &raquo;

<div class="p"><!----></div>
-  <i>Квантор всеобщности</i> &#8704;, который гласит &laquo;Для всех (или: для любого) <i>x</i> (в...),... &raquo;). 

<div class="p"><!----></div>
Они могут быть мета-определяемыми с помощью мета-функции (<i>x</i> &#x21A6; &#120033;(<i>x</i>)) с одной и той же областью в силу

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
(&#8704;<i>x</i>,&#120033;(<i>x</i>))&nbsp;&nbsp;&#8660;&nbsp;&nbsp;(<i>x</i> &#x21A6; &#120033;(<i>x</i>))=(<i>x</i> &#x21A6; 1)&nbsp; &#x21CE; &nbsp;(&#8707;<i>x</i>, &#172;&#120033;(<i>x</i>))&nbsp;&#8660;&nbsp;&nbsp;(<i>x</i> &#x21A6; &#172;&#120033;(<i>x</i>)) &#8800; (<i>x</i> &#x21A6; 0)</td></tr></table>
</td></tr></table>


В теории множеств, (&#8704;<i>x</i> &#8712; <i>E</i>,&#120033;(<i>x</i>))&nbsp;&#8660;&nbsp;{<i>x</i> &#8712; <i>E</i>&#124;&#120033;(<i>x</i>)}=<i>E</i>. 
Формула (&#8704;<i>x</i>,1) всегда истинна.
С классами,

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(&#8707;<sub>&#120018; </sub> <i>x</i>,&#120033;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;(&#8707;<i>x</i>, &#120018;(<i>x</i>) &nbsp;&#8743;&nbsp;&#120033;(<i>x</i>))&nbsp;&#8660;&nbsp;&#8707;<sub>&#120018;&#8743;&#120033;</sub> <i>x</i>,1</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 (&#8704;<sub>&#120018; </sub> <i>x</i>,&#120033;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8660;&nbsp;(&#8704;<i>x</i>, &#120018;(<i>x</i>) &nbsp;&#8658;&nbsp;&#120033;(<i>x</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&#8704;<i>x</i>,(&#120018;(<i>x</i>)</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&#8660;&nbsp;(&#8707;<sub>&#120018; </sub> <i>y</i>, <i>x</i>=<i>y</i>))</td></tr></table></td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
<br /><i>Включение между классами</i>

<div class="p"><!----></div>
Считается, что Класс &#120016; включен в класс &#120017; когда &#8704;<i>x</i>, &#120016;(<i>x</i>)&nbsp;&#8658;&nbsp;&#120017;(<i>x</i>). Тогда &#120016; - это подкласс &#120017;, как &#8704;<i>x</i>,&#120016;(<i>x</i>)&nbsp;&#8660;&nbsp;(&#120017;(<i>x</i>)&nbsp;&#8743;&nbsp;&#120016;(<i>x</i>)). И наоборот, любой подкласс &#120016;  включен в подкласс &#120017; что подразумевает для любого предиката &#120018; (в случаях определенности):

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(&#8704;<sub>&#120017;</sub> <i>x</i>, &#120018;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8658;&nbsp;(&#8704;<sub>&#120016;</sub> <i>x</i>, &#120018;(<i>x</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(&#8707;<sub>&#120016;</sub> <i>x</i>, &#120018;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8658;&nbsp;(&#8707;<sub>&#120017;</sub> <i>x</i>, &#120018;(<i>x</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
(&#8707;<sub>&#120018; </sub><i>x</i>, &#120016;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
&nbsp;&#8658;&nbsp;(&#8707;<sub>&#120018; </sub><i>x</i>, &#120017;(<i>x</i>))</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 (&#8704;<sub>&#120018; </sub><i>x</i>, &#120016;(<i>x</i>))</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1">&nbsp;&#8658;&nbsp;(&#8704;<sub>&#120018; </sub><i>x</i>, &#120017;(<i>x</i>))</td></tr></table></td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
<br /><i>Правила доказательств для квантификаторов по унарному предикату</i> &#120033;

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><span class="small">E</span></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><span class="small">T</span></sub>H</a>,
version 4.03.<br />On  3 Oct 2013, 13:20.</small>
</html>
